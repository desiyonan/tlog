[{"content":"思维导图  Spring  容器启动的过程 FactoryBean原理 Bean的生命周期 Bean的创建过程 Spring boot 自动装配原理     流程类图 容器启动过程 @startuml 'spring boot启动过程' class \u0026quot;SpringApplication\u0026quot; as sapp { - Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; primarySources - Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; sources - ConfigurableEnvironment environment - WebApplicationType webApplicationType - List\u0026lt;ApplicationContextInitializer\u0026lt;?\u0026gt;\u0026gt; initializers - List\u0026lt;ApplicationListener\u0026lt;?\u0026gt;\u0026gt; listeners - ApplicationContextFactory applicationContextFactory - Class\u0026lt;?\u0026gt; mainApplicationClass + SpringApplication(Class\u0026lt;?\u0026gt;... primarySources) + SpringApplication(ResourceLoader, Class\u0026lt;?\u0026gt;... primarySources) + Collection\u0026lt;T\u0026gt; getSpringFactoriesInstances(Class\u0026lt;T\u0026gt; type) - DefaultBootstrapContext createBootstrapContext() # ConfigurableApplicationContext createApplicationContext() - void prepareContext(DefaultBootstrapContext,ConfigurableApplicationContext,...) # void applyInitializers(ConfigurableApplicationContext) - void refreshContext(ConfigurableApplicationContext) + {static} ConfigurableApplicationContext run(Class\u0026lt;?\u0026gt; primarySource, String... args) + {static} ConfigurableApplicationContext run(Class\u0026lt;?\u0026gt;[] primarySources, String[] args) + ConfigurableApplicationContext run(String... args) } note left of sapp::getSpringFactoriesInstances 类似JavaSPI机制，提供拓展功能 BootstrapRegistryInitializer与 ApplicationContextInitializer还 有ApplicationListener可以通过这 种方式直接优先配置 end note note left of sapp::createBootstrapContext 创建DefaultBootstrapContext 并应用BootstrapRegistryInitializer end note note left of sapp::createApplicationContext 通过applicationContextFactory创 建应用上下文 end note note left of sapp::prepareContext 应用上下文的处理： 1.注册一些启动特殊单例bean 2.加载应用主类primarySources end note note left of sapp::applyInitializers 对应用上下文调用 ApplicationContextInitializer初始化方法 end note note left of sapp::refreshContext 1.调用shutdownhook 2.最后实际调用applicationContext.refresh end note note left of sapp::run 常用启动方式，静态方法，返回容器 上下文，核心调用refreshContext 最后callRunner end note interface \u0026quot;ApplicationContextFactory\u0026quot; as acf { + ApplicationContextFactory DEFAULT + ConfigurableApplicationContext create(WebApplicationType) } note right of acf::DEFAULT 根据不同的应用类型创建对应 的上下文实例 end note interface \u0026quot;ConfigurableApplicationContext\u0026quot; as cacxt { + void refresh() + ConfigurableListableBeanFactory getBeanFactory() } note left of cacxt::refresh 核心接口方法声明 end note abstract class \u0026quot;AbstractApplicationContext\u0026quot; as aac{ - List\u0026lt;BeanFactoryPostProcessor\u0026gt; beanFactoryPostProcessors - ResourcePatternResolver resourcePatternResolver - LifecycleProcessor lifecycleProcessor - ApplicationEventMulticaster applicationEventMulticaster - final Set\u0026lt;ApplicationListener\u0026lt;?\u0026gt;\u0026gt; applicationListeners - Set\u0026lt;ApplicationListener\u0026lt;?\u0026gt;\u0026gt; earlyApplicationListeners - Set\u0026lt;ApplicationEvent\u0026gt; earlyApplicationEvents + void refresh() } note left of aac::refresh 实现核心方法 end note class \u0026quot;GenericApplicationContext\u0026quot; as gac \u0026lt;\u0026lt;BeanDefinitionRegistry\u0026gt;\u0026gt;{ } note left of gac BeanDefinitionRegistry接口 提供注册bean的功能 end note class \u0026quot;AnnotationConfigServletWebServerApplicationContext\u0026quot; as acswsac { } sapp::applicationContextFactory \u0026lt;-- acf sapp \u0026lt;.. cacxt cacxt .\u0026gt; acf:工厂创建 cacxt \u0026lt;|.. aac acf .[hidden]. aac aac \u0026lt;|-- gac gac \u0026lt;|- acswsac acf \u0026lt;... acswsac @enduml FactoryBean注入原理 @startuml 'FactoryBean原理' interface \u0026quot;FactoryBean\u0026lt;T\u0026gt;\u0026quot; as fb { + String OBJECT_TYPE_ATTRIBUTE = \u0026quot;factoryBeanObjectType\u0026quot; + T getObject() + Class\u0026lt;?\u0026gt; getObjectType() + boolean isSingleton() } class \u0026quot;ClassPathBeanDefinitionScanner\u0026quot; as cpbds{ - BeanDefinitionRegistry registry + int scan(String... basePackages) # Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) } class \u0026quot;ClassPathMapperScanner\u0026quot; as cpms implements cpbds { - Class\u0026lt;? extends Annotation\u0026gt; annotationClass - Class\u0026lt;? extends MapperFactoryBean\u0026gt; mapperFactoryBeanClass = MapperFactoryBean.class + void registerFilters() + Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) - void processBeanDefinitions(Set\u0026lt;BeanDefinitionHolder\u0026gt;) } class \u0026quot;MapperFactoryBean\u0026quot; as mfb implements fb { - boolean addToConfig = true - Class\u0026lt;T\u0026gt; mapperInterface - SqlSessionTemplate sqlSessionTemplate + void checkDaoConfig() + T getObject() } interface \u0026quot;BeanDefinitionRegistry\u0026quot; as bdr { ... + void registerBeanDefinition(String beanName, BeanDefinition) } interface \u0026quot;BeanFactory\u0026quot; as bf { + Object getBean(String name,...) + Object getBean(Class,...) } interface \u0026quot;HierarchicalBeanFactory\u0026quot; as hbf extends bf{ + BeanFactory getParentBeanFactory() } interface \u0026quot;ConfigurableBeanFactory\u0026quot; as cbf extends hbf{ + BeanDefinition getMergedBeanDefinition(String name) + boolean isFactoryBean(String name) } class \u0026quot;AbstractBeanFactory\u0026quot; as abf \u0026lt;\u0026lt;FactoryBeanRegistrySupport\u0026gt;\u0026gt; implements cbf { + Object getBean(String name,...) # T doGetBean(String name,Class\u0026lt;T\u0026gt;,Object[] args,typeCheckOnly) # Object getObjectForBeanInstance(beanInstance,name,beanName,RootBeanDefinition ) } note bottom of abf 方法内判断beanInstance是否为FactoryBean 如果是则通过FactoryBeanRegistrySupport获取 end note class \u0026quot;DefaultListableBeanFactory\u0026quot; as dlbf{ - Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap - volatile List\u0026lt;String\u0026gt; beanDefinitionNames + void registerBeanDefinition(String beanName, BeanDefinition) + Object getBean(...) } cpms \u0026lt;--- mfb cpbds \u0026lt;- bdr bdr \u0026lt;.... dlbf abf \u0026lt;|-- dlbf fb -\u0026gt; abf::getObjectForBeanInstance @enduml Spring Boot 自动装配原理 源码版本：2.7.0-SNAPSHOT\n入口类：\n @org.springframework.boot.autoconfigure.EnableAutoConfiguration @org.springframework.context.annotation.Configuration @org.springframework.context.annotation.Conditional  核心类:\n org.springframework.boot.autoconfigureAutoConfigurationImportSelector org.springframework.core.io.support.SpringFactoriesLoader org.springframework.boot.autoconfigure.AutoConfigurationImportFilter  @startuml title: Spring Boot 自动装配原理 annotation \u0026quot;EnableAutoConfiguration\u0026quot; as eac { Class\u0026lt;?\u0026gt; exclude() String[] excludeName() } package \u0026quot;获取配置类名过程\u0026quot; \u0026lt;\u0026lt;Frame\u0026gt;\u0026gt; { class \u0026quot;AutoConfigurationImportSelector\u0026quot; as acis \u0026lt;\u0026lt;DeferredImportSelector\u0026gt;\u0026gt; { + String[] selectImports(AnnotationMetadata) # AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata) # List\u0026lt;String\u0026gt; getCandidateConfigurations(...) - ConfigurationClassFilter getConfigurationClassFilter() } class \u0026quot;SpringFactoriesLoader\u0026quot; as sfl { + {static} List\u0026lt;T\u0026gt; loadFactories(Class\u0026lt;T\u0026gt; factoryType, ClassLoader) + {static} List\u0026lt;String\u0026gt; loadFactoryNames(Class\u0026lt;?\u0026gt; factoryType, ClassLoader) } interface \u0026quot;AutoConfigurationImportFilter\u0026quot; as acif { + boolean[] match(String[] configClassName, AutoConfigurationMetadata) } note bottom of acif 顶层过滤接口， ConditionalOnBean, ConditionalOnMissingBean, ConditionalOnClass 等条件注解通过其子类实现功能， 具体实现先略过 end note entity \u0026quot;META-INF/spring.factories\u0026quot; as file{ configClass=classA,classB... ... --- e.g： MybatisAutoConfiguration } hide file circle } eac \u0026lt;-- acis: 通过Spring的@Import注解\\n方式导入容器,详细另出 acis \u0026lt;- acif acis \u0026lt;-- sfl: 只是获取配置类名 sfl \u0026lt;-- file note right on link 通过ClassLoader加载所有 jar包下的相应文件，解析 并缓存。 这里获取所有Key为 EnableAutoConfiguration 的类名，可以参考 MybatisAutoConfiguration 的具体配置 end note @enduml ","permalink":"https://zone.dnfn.tech/post/c7b86b2ba56d9f263bba0e1d89ac436f/","summary":"","title":"提纲挈领-Spring"},{"content":"思维导图  mybatis  1.配置阶段  1.自动装配过程 2.接口扫描过程 3.接口动态代理 4.接口方法映射   2.运行阶段  1.接口方法执行 2.插件链的处理       配置阶段 源码版本：\n\u0026lt;!-- pom.xml --\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1-SNAPSHOT\u0026lt;/version\u0026gt; 自动装配过程 基于spring-autoconfig，SPI动态扩展\n@startuml class \u0026quot;MybatisAutoConfiguration\u0026quot; as mac { - MybatisProperties properties - Interceptor[] interceptors - ResourceLoader resourceLoader + SqlSessionFactory sqlSessionFactory(DataSource dataSource) + SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) } note left of mac 通过spring.factories文件 配置，类似java的SPI机制 主要功能： 1. 声明Bean: SqlSessionFactory 2. 声明Bean: SqlSessionTemplate 3. 创建Configuration 4. 配置Mapper扫描 end note class \u0026quot;MybatisProperties\u0026quot; as mp{ - String configLocation - String[] mapperLocations - String typeAliasesPackage - String typeHandlersPackage - boolean checkConfigLocation - ExecutorType executorType - Properties configurationProperties - Configuration configuration + Resource[] resolveMapperLocations() } note top of mp yml配置文件中前缀为`mybatis`的配置项 声明config文件位置，还有yml中的配置 end note class \u0026quot;AutoConfiguredMapperScannerRegistrar\u0026quot; as msr \u0026lt;\u0026lt;ImportBeanDefinitionRegistrar\u0026gt;\u0026gt; { - BeanFactory beanFactory + void registerBeanDefinitions(AnnotationMetadata, BeanDefinitionRegistry) } note left of msr 实现ImportBeanDefinitionRegistrar接口 注入MapperScannerConfigurer实例，用于 配置扫描Mapper end note interface \u0026quot;BeanDefinitionRegistry\u0026quot; as bdr { ... + void registerBeanDefinition(String beanName, BeanDefinition) } interface \u0026quot;BeanDefinitionRegistryPostProcessor\u0026quot; as bdrpp \u0026lt;\u0026lt;BeanFactoryPostProcessor\u0026gt;\u0026gt;{ + void postProcessBeanFactory(ConfigurableListableBeanFactory) + void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) } class \u0026quot;DefaultListableBeanFactory\u0026quot; as dlbf { - Map\u0026lt;String, BeanDefinition\u0026gt; beanDefinitionMap - volatile List\u0026lt;String\u0026gt; beanDefinitionNames } class \u0026quot;ClassPathBeanDefinitionScanner\u0026quot; as cpbds{ - BeanDefinitionRegistry registry + int scan(String... basePackages) # Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) } class \u0026quot;MapperScannerConfigurer\u0026quot; as msc \u0026lt;\u0026lt;BeanDefinitionRegistryPostProcessor\u0026gt;\u0026gt;{ - Class\u0026lt;? extends Annotation\u0026gt; annotationClass - String basePackage - 其他属性.. + void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry) } class \u0026quot;ClassPathMapperScanner\u0026quot; as cpms{ - Class\u0026lt;? extends Annotation\u0026gt; annotationClass - Class\u0026lt;? extends MapperFactoryBean\u0026gt; mapperFactoryBeanClass = MapperFactoryBean.class + void registerFilters() + Set\u0026lt;BeanDefinitionHolder\u0026gt; doScan(String... basePackages) - void processBeanDefinitions(Set\u0026lt;BeanDefinitionHolder\u0026gt;) } note left of cpms::registerFilters 设置过滤，扫描Mapper注解 this.addIncludeFilter(new AnnotationTypeFilter(this.annotationClass)); end note note left of cpms::processBeanDefinitions 核心处理方法,将扫描到的类设置为MapperFactoryBean.class definition.setBeanClass(this.mapperFactoryBeanClass) 设置依赖sqlSessionFactory等 end note interface \u0026quot;FactoryBean\u0026lt;T\u0026gt;\u0026quot; as fb { + String OBJECT_TYPE_ATTRIBUTE = \u0026quot;factoryBeanObjectType\u0026quot; + T getObject() + Class\u0026lt;?\u0026gt; getObjectType() + boolean isSingleton() } note left of fb::getObject 最终生成实例代理类 end note class \u0026quot;DaoSupport\u0026quot; as ds \u0026lt;InitializingBean\u0026gt; { + void afterPropertiesSet() + void checkDaoConfig() + void initeDao() } note right of ds::afterPropertiesSet 调用checkDaoConfig，最终通 过Configuration.addMapper 添加mapper end note class \u0026quot;SqlSessionDaoSupport\u0026quot; as ssds extends ds { + void checkDaoConfig() } class \u0026quot;MapperFactoryBean\u0026quot; as mfb extends ssds implements fb { - boolean addToConfig = true - Class\u0026lt;T\u0026gt; mapperInterface - SqlSessionTemplate sqlSessionTemplate + void checkDaoConfig() + T getObject() } note left of mfb::mapperInterface 业务代码定义的类，注解Mapper修饰 end note note right of mfb::sqlSessionTemplate 通过模板获取到之前生成的configuration 配置 end note note right of mfb::checkDaoConfig 重写，调用Configuration.addMapper添加 end note note left of mfb::getObject 通过Configuration生成过去代理类 end note class \u0026quot;Configuration\u0026quot; as cfg{ - MapperRegistry mapperRegistry + bool hasMapper(Class) + void addMapper(Class) } note left of cfg MybatisProperties声明的文件位置， MybatisAutoConfigurtion创建的配置 end note class \u0026quot;MapperRegistry\u0026quot; as mr { - Map\u0026lt;Class\u0026lt;?\u0026gt;, MapperProxyFactory\u0026lt;?\u0026gt;\u0026gt; knownMappers + boolean hasMapper(Class\u0026lt;T\u0026gt;) + void addMapper(Class\u0026lt;T\u0026gt;) + void getMapper(Class\u0026lt;T\u0026gt;, SqlSession) } note left of mr 注册Mapper，和生成Mapper代理工厂， 通过Mapper代理工厂最终生成代理类提供给 Spring容器 end note class \u0026quot;MapperProxyFactory\u0026lt;T\u0026gt;\u0026quot; as mpf{ - Class mapperInterface - Map\u0026lt;Method, MapperMethodInvoker\u0026gt; methodCache + T newInstance(SqlSession) } class \u0026quot;MapperProxy\u0026quot; as mproxy \u0026lt;\u0026lt;InvocationHandler\u0026gt;\u0026gt; { - SqlSession sqlSession - Class\u0026lt;T\u0026gt; mapperInterface - Map\u0026lt;Method, MapperProxy.MapperMethodInvoker\u0026gt; methodCache } note left of mproxy 最终注入容器的JDK代理类， 解析定义的Mapper接口方法并缓存句柄 运行时执行 end note mac::properties \u0026lt;- mp mac \u0026lt;-- msr : @Import导入配置 msr::registerBeanDefinitions \u0026lt;. bdr bdr \u0026lt;|.. dlbf: 注册信息保存在Map中 msr .[hidden]. bdrpp msr \u0026lt;--- msc bdrpp \u0026lt;|.. msc msc \u0026lt;-- cpms bdr \u0026lt;--- cpbds cpbds \u0026lt;|.. cpms cpms \u0026lt;--- mfb fb .[hidden] (cpms, mfb) mfb \u0026lt;-- cfg cfg \u0026lt;-- mr mr \u0026lt;-- mpf mpf \u0026lt;-- mproxy @enduml 运行阶段 Mybatis 接口方法执行流程 源码版本:\nJDK8和JDK9之后稍有不同，之后版本方法通过方法句柄实现，功能一致，没有太大区别\n@startuml annotation Service class XXService { - mapper:IMapper } interface IMapper { + Object doSomething() } class MapperProxy \u0026lt;\u0026lt;InvocationHandler\u0026gt;\u0026gt; { - SqlSession sqlSession - Class\u0026lt;T\u0026gt; mapperInterface - Map\u0026lt;Method, MapperMethod\u0026gt; methodCache } class MapperMethod { - SqlCommand command - MethodSignature method + Object execute(SqlSession sqlSession, Object[] args) - Object rowCountResult(int rowCount) } class SqlCommand{ - String name - SqlCommandType type } class MethodSignature { - boolean returnsMany - boolean returnsMap - boolean returnsVoid - Class\u0026lt;?\u0026gt; returnType - String mapKey - Integer resultHandlerIndex - Integer rowBoundsIndex - SortedMap\u0026lt;Integer, String\u0026gt; params - boolean hasNamedParameters + Object convertArgsToSqlCommandParam(Object[] args) + RowBounds extractRowBounds(Object[] args) + ResultHandler extractResultHandler(Object[] args) } interface SqlSession { - void select(...) - List selectList(...) } class DefaultSqlSession { - Executor executor } interface Executor { + List query(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4) + List query(...) } abstract class BaseExecutor implements Executor { - PerpetualCache localCache - List queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) # abstract List doQuery(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4, BoundSql var5) } class SimpleExecutor extends BaseExecutor{ + List doQuery(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4, BoundSql var5) } interface StatementHandler { + List query(Statement var1, ResultHandler var2) } class RoutingStatementHandler { - StatementHandler delegate } class Configuration { - InterceptorChain interceptorChain + StatementHandler newStatementHandler(...) } class InterceptorChain{ - List\u0026lt;Interceptor\u0026gt; interceptors + Object pluginAll(Object target) + void addInterceptor(Interceptor interceptor) } interface Interceptor { + Object intercept(Invocation var1) throws Throwable + Object plugin(Object var1) + void setProperties(Properties var1) } class Plugin \u0026lt;\u0026lt;InvocationHandler\u0026gt;\u0026gt; { - Object target - Intercepor interceptor - Map\u0026lt;Class\u0026lt;?\u0026gt;, Set\u0026lt;Method\u0026gt;\u0026gt; signatureMap + Object wrap(Object target, Interceptor interceptor) } interface ResultHandler { + List handleResultSets(Statement var1) } interface PreparedStatement { + void execute() } XXService .\u0026gt; Service XXService \u0026lt;-- IMapper : 成员变量 XXService \u0026lt;-- MapperProxy : spring容器注入实例 MapperProxy -left- IMapper : JDK动态代理 MapperProxy o-- MapperMethod : Map缓存 MapperMethod -left\u0026gt; SqlCommand MapperMethod -\u0026gt; MethodSignature MapperMethod \u0026lt;.. SqlSession : execute参数调用 SqlSession \u0026lt;|-- DefaultSqlSession DefaultSqlSession -\u0026gt; Executor SimpleExecutor \u0026lt;.. StatementHandler : Plugin层层代理过后的实例 StatementHandler \u0026lt;|--- RoutingStatementHandler StatementHandler \u0026lt;|--- PreparedStatementHandler Configuration \u0026lt;.... RoutingStatementHandler : 构建并应用插件链 Configuration .\u0026gt; SimpleExecutor Configuration \u0026lt;-- InterceptorChain InterceptorChain o.. Interceptor: pluginAll层层包装target(JDK动态代理) Interceptor \u0026lt;.. Plugin : Plugin.warp 包装成代理类 Interceptor --\u0026gt; Plugin InterceptorChain .[hidden] StatementHandler Plugin = RoutingStatementHandler : JDK动态代理 RoutingStatementHandler -- PreparedStatementHandler: 静态代理 PreparedStatement .\u0026gt; PreparedStatementHandler PreparedStatementHandler \u0026lt;. ResultHandler @enduml ","permalink":"https://zone.dnfn.tech/post/ddc9e90cd9852e2ffeb3f84ed81fe3f6/","summary":"","title":"提纲挈领-Mybatis"},{"content":"思维导图  hashmap  1.定义特征  键值对数据结构 键可为NULL 散列表 线程不安全 无序   2.类型关系  继承树 HashTable TreeMap LinkedHashMap   3.内部实现  存储：数据结构  JDK7：数组+链表 JDK8：数组+链表+红黑树 属性  容量  默认：16 上限：初始化不超过1\u0026laquo;30  为什么不是1\u0026laquo;31     扩容因子  默认0.75，大于0  0.75的原因   扩容时机：元素数量超过阈值   阈值（容量*扩容因子）  默认：12， 上限：Integer.MAX_VALUE   转树的阈值  设置为8  原因：概率小         寻址：基于hash算法  键的hash值高低16位异或 哈希冲突：链地址法     4.属性 5.方法  构造方法  无参构造 容量构造 容量+扩容因子构造 map构造   重要方法  出  get getOrDefault remove   入  put putAll putIfAbsent   其他  compute  计算然后返回最后结果（新值|null），可插入|更新|删除   computeIfAbsent  如果没有则计算（返回原值|新值|null），可插入   computeIfPresent  如果已有则计算（返回新值|null），可更新|删除   merge replace replaceAll       6.核心  扩容  方法  tableSizeFor：初始化阈值大小，作为hashmap第一次初始化扩容时的容量 resize：扩容函数   时机  第一次put元素初始化 元素数量达到阈值   方式  默认初始容量为16，之后容量=容量*2，最大1\u0026laquo;30 阈值=阈值*2 迁移元素     链表转树  哈希冲突链表长度超过8时         ","permalink":"https://zone.dnfn.tech/post/cca5741dfd7b1c01379bf6722f388bf3/index.json","summary":"","title":"提纲挈领-HashMap思维导图"},{"content":"","permalink":"https://zone.dnfn.tech/photo/376f72a0f58de1dac0fd42a647ec3463/","summary":"","title":"相册"},{"content":"思维导图  synchroized  基本作用  加锁代码块，只能一个线程访问   基本用法  修饰方法 同步对象 同步类   JVM 原理  对象头  布局 偏向锁 锁标志   管程对象  属性 核心  _EntryList _WaitSet _Owner     实现 优化  偏向锁 自旋锁 轻量级锁 锁消除         延伸  深入理解Java并发之synchronized实现原理 Java synchronized 详解  ","permalink":"https://zone.dnfn.tech/post/74a5930c895c8362231c72b1079a7d91/","summary":"","title":"Synchronized关键字解析"},{"content":" volatile  1.具体含义作用  含义  线程之间共享可见的变量   作用  1.保证变量在线程间的可见性 2.对该变量的访问禁用指令重排     2.并发编程概念  原子性\n一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n例子\nx = 10\nx++\nx=x+2 可见性  多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值   有序性  程序执行的顺序按照代码的先后顺序执行 指令重排  单线程不影响，多线程有问题       3.物理硬件架构  图例  简单图示 图例2 图例   概念  主存 - 内存 CPU高速缓存  意义  CPU运行速度和内存读写速度差异过大，引入三级缓存防止频繁读取内存影响运行速度   组成  L1  组成  L1i  一级指令缓存   L1d  一级数据缓存     最近，最小，最快 核专属  一个核独享一个一级缓存     L2  二级缓存 核专属  一个核独享一个二级缓存     L3  三级缓存 座专属  一个CPU座(多核)共享一个三级缓存       大小  lscpu查看     CPU缓存行  定义  CPU缓存的基本单位   大小  2的整数幂个连续字节，一般为32-256个字节 常见为64字节   作用  缓存内存空间中连续的一段数据 数组将缓存其后相邻的元素  加快顺序访问   字段将缓存相邻的几个字段  伪共享       Store Buffer  CPU核心与CPU缓存之间的一个存储缓冲 作用  目的是为了提升本CPU效率，将同步变异步 将写非本CPU的独享变量与同步通知其他CPU把缓存置为无效的过程通过异步处理  1.当前CPU修改不是自己的独享变量 2.1写入本CPU的Store Buffer 2.2通知其他CPU设置无效缓存行 1.获得响应ACK 2.将Store Buffer中的对应数据写入Cache     副作用  单个CPU内的指令乱序  现象  本CPU修改其他CPU的独享变量后，马上读取还是原来的值（有延迟，好比和后续代码顺序调换） 图例   原因  最开始的设计：（对非本CPU的独享变量）写操作先缓存至Store Buffer，读从直接从相应CPU那获取；写入Store Buffer与写入Cache是有延迟的（通知与等待ACK）   解决  Store Forwarding  直接从Store Buffer读取已修改的缓存数据       多个CPU之间变量的不正确同步  现象  几个变量在一个CPU里的有执行的顺序关系，但是在另一个CPU里这种关系却不成立 时序图  图例     原因  其他CPU修改某CPU的独享变量需要发送请求，但是是异步的，修改自身的独享变量是直接操作Cache 读取其他CPU的独享变量是通信同步的，所以是正确的 读取自身CPU的独享变量可以直接从Cache获取  读取都是同步顺序的，但如果发生变量被其他CPU修改，当前CPU的缓存行状态变化可能就会不及时     解决  内存屏障         Invalid Queue  一个队列，用于存储其他CPU向当前CPU发出的请求，置某些缓存行为无效的消息 作用  目的是为了提升其他CPU效率 加快响应其他CPU发出的置缓存行为无效的请求  直接返回ACK 将消息放入队列中，后续处理  处理时机：处理任何缓存行的MSEI状态前 遗漏：本CPU的独享变量读取  使用读屏障解决  遇到读屏障会把队列的消息处理了，然后处理屏障后的操作               影响  缓存一致性  CPU缓存加快数据的访问数据，但是多线程下对共享变量的读写将会存在延时，影响可见性   指令重排  为了提升CPU的运行速度，但破坏了指令的有序性 分类  主动的  编译器优化，使得CPU更快执行指令   被动的  CPU流水线操作延迟。为了异步化指令的执行，引入Store Buffer和Invalidate Queue，却导致了「指令顺序改变」的副作用         处理  总线锁  阻塞其他CPU访问内存，效率低下，早期采用的方案   缓存一致性协议  分类  MESI  状态  M  修改  该缓存行有效，数据被修改了，和内存中的数据不一致，数据只存在于本缓存行中     E  独享  该缓存行有效，数据和内存中的数据一致，数据只存在于本缓存行中     S  共享  该缓存行有效，数据和内存中的数据一致，数据同时存在于其他缓存中     I  无效  该缓存行数据无效       转换  图例     MSI MOSI   目的  解决多个CPU之间缓存不可见的问题   副作用  CPU性能降低  需要与其他CPU通信，通知响应和请求数据   指令乱序  原因：为了提升CPU的运行，引入异步通信（Store Buffer\u0026amp;Invalid Queue），处理缓存有延迟 解决：提供内存屏障解决       内存屏障  现象  Load-Store Store-Load Load-Load Store-Store   分类  写屏障  分类  简单刷入，等待刷入完再继续执行，即变为同步  一步一步完成，完成一个指令再执行下一行指令   还是异步，把屏障后的操作也暂时缓存，一起刷入  写屏障后的写操作也跟同(写屏障标记的操作)写入Store Buffer中先缓冲，\\n使得其他CPU想获取当前CPU的独享变量只能获取Cache中之前的值， \\n直到当前CPU在适当时机（不太清楚，应该是获得ACK），才会把写屏障标记及之后的数据一同写入Cache 实现写的可见性，写数据顺序的可见性  1.写远程缓存数据 2.写本地缓存数据  写屏障后的本地写操作   3.获取到远程响应   解决的问题  远程写是异步的，本地写是同步的 \\n远程写是往Store Buffer，本地写是往Cache \\n实现原理：遇到写屏障把写屏障标记及之后的缓存都写入Store Buffer（即便是本地写），解除标记时全部写入Cache   把写屏障与获得ACK之间的写操作视为一个整体缓存和再刷入     区别  同步的对其他CPU而言可以更快拿到缓存更新结果，\\n 异步的对当前CPU而言效率更高，但是对其他CPU而言需要晚一步     读屏障  遇到读屏障，则将Invalid Queue中的数据全部处理完 实现读的可见性，读（远程写）的可见性  1.响应远程写 2.远程写消息放入 Invalid Queue，待处理 3.已经可以读到远程CPU（它自己本地的）缓存数据的修改 4.想要当前CPU之前独享的缓存数据  按道理，已经可以读到远程CPU修改过（它本地）的变量，\\n那么远程CPU修改过（当前CPU）的变量应该同样可见才是，\\n 因为远程CPU写屏障已经解除了（已经获取到了ACK），\\n但实际当前CPU还没有处理，消息依旧在Invalid Queue中， 遇到读屏障，将已无效的缓存处理掉，之后不再从Cache中读，以防脏读   5.远程读（之前远程写）相应的缓存行  获取正确的缓存     解决的问题  远程读是同步的，本地读是同步的，处理远程写是异步的\\n 本地读直接从Cache中获取，远程写的通知消息可能还在在Invalid Queue中     全屏障         4.JVM内存模型  图例  JVM内存模型 图 图   意义  屏蔽硬件和操作系统访问内存的差异，保证在各个平台和系统对内存的访问效果一致 对CPU物理硬件层的抽象   抽象结构  主内存  堆 共享变量的存储位置   工作内存  CPU寄存器和高速缓存 线程对变量的操作发生的位置 线程不能直接读写主内存     happen-before规则  1.程序次序  一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作   2.锁定规则  一个unLock操作先行发生于后面对同一个锁额lock操作   3.共享变量规则  对一个变量的写操作先行发生于后面对这个变量的读操作   4.传递规则  如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C   5.线程启动规则  Thread对象的start()方法先行发生于此线程的每个一个动作   6.线程中断规则  对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生   7.线程终结规则  线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行   8.对象终结规则  一个对象的初始化完成先行发生于他的finalize()方法的开始     线程工作内存与主内存的动作交互  图例     5.JVM实现原理  Lock前缀指令  总线锁  总线只有一条，且为独占的，同一时间，只有一个CPU能占用总线 当通过LOCK#信号锁定总线后，其他CPU访问内存的请求将被阻塞，直到总线被释放，保证了读写的原子性 主要使用场景  1.处理器不支持缓存锁定，比如 Intel486、Pentlum 2.处理的数据不能被缓存在CPU时 3.操作的数据跨多个缓存行时     缓存锁  当前CPU修改变量，会直接写入内存中 缓存一致性协议，阻止同时修改 大致过程  1.线程A执行，写volatile变量，执行到Lock前缀指令 2.Lock前缀指令，锁定缓存行 3.其他线程通过总线嗅探获知消息，然后将各自工作内存中的相应的缓存置为无效 4.线程A将最新数据写入主存 5.释放缓存行的锁 6.其他CPU通过缓存一致性协议保持最新值，读取时，从主存中加载         6.相关实际应用  1.双重校验锁定模式 - 单例模式  目的是避免指令重排：初始化对象与变量引用赋值可能颠倒。\\n 避免其他线程拿到未初始化的对象进行操作 代替方案：基于内部类初始化   2.状态标记       延伸 ","permalink":"https://zone.dnfn.tech/post/868e28684b69bf0f96b71767551a3e30/","summary":"","title":"Volatile关键字解析"},{"content":"前言 手上一个war老项目，tomcat部署的，一般情况下idea配置的Hot Swap就行了。今天前端突然问加的新文件为啥没热部署到Tomcat，文件更新又能热部署成功，就很纳闷。\n尝试了直接build或rebuild模块和项目都不成，idea的编译器的autobuild都没问题，最后再StackOverflow找到相关的解决方法：\nFile -\u0026gt; Project Structure -\u0026gt; Artifacts -\u0026gt; Include in project build\n如下：\n\n配置成功，自动构建时也会构建Artifacts。\nPASS: 事后发现，通过idea资源窗口复制两次文件再build，只会把第一次的文件编译到tagert下，不过直接通过win的文件管理器不会有这种问题。\n","permalink":"https://zone.dnfn.tech/post/3b1a32308bc6174e0c519d645bf1caad/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e手上一个war老项目，tomcat部署的，一般情况下idea配置的\u003ccode\u003eHot Swap\u003c/code\u003e就行了。今天前端突然问加的新文件为啥没热部署到Tomcat，文件更新又能热部署成功，就很纳闷。\u003c/p\u003e\n\u003cp\u003e尝试了直接\u003ccode\u003ebuild\u003c/code\u003e或\u003ccode\u003erebuild\u003c/code\u003e模块和项目都不成，idea的编译器的\u003ccode\u003eautobuild\u003c/code\u003e都没问题，最后再\u003ca href=\"https://stackoverflow.com/questions/44351098/intellij-automatically-build-artifacts-when-code-changes\" title=\"intellij-automatically-build-artifacts-when-code-changes\"\u003eStackOverflow\u003c/a\u003e找到相关的解决方法：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eFile\u003c/code\u003e -\u0026gt; \u003ccode\u003eProject Structure\u003c/code\u003e -\u0026gt; \u003ccode\u003eArtifacts\u003c/code\u003e -\u0026gt; \u003ccode\u003eInclude in project build\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e如下：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://oss.dnfn.tech:1024/bedroom/2021/8/18/20210818183315.png\" title=\"Include in project build\"\u003e\u003cimg loading=\"lazy\" src=\"https://oss.dnfn.tech:1024/bedroom/2021/8/18/20210818183315.png\" alt=\"P1\"  title=\"Include in project build\"  /\u003e\n\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e配置成功，自动构建时也会构建\u003ccode\u003eArtifacts\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003ePASS: 事后发现，通过idea资源窗口复制两次文件再\u003ccode\u003ebuild\u003c/code\u003e，只会把第一次的文件编译到\u003ccode\u003etagert\u003c/code\u003e下，不过直接通过win的文件管理器不会有这种问题。\u003c/p\u003e","title":"War包新增文件无法自动部署"},{"content":"简介 网站虽小，但评论功能不能少，万一哪天有老哥想跟我唠嗑呢？先用utterances搞个评论功能撑撑场面。\n前言 看阮一峰老哥的博客评论才反应过来，Hugo搭建的静态网站没有自带的评论功能，还需要三方支撑，不过支持种类倒是不少：\n\n这里为了简单点，我采取了方案Utterances\n本网站的环境：\ntheme:PaperModconfig:yml需要做的事:\n 一个pulic repo: 由于我本身就用了两个repo(一个私有源码，一个自动构建后的github pages)，所以我直接把评论也放到构建后的repo 上面的repo需要安装utterances 配置参数和模板  添加需要的参数，config\\_default\\params.yml：\nutter:repo:desiyonan/zoneissueTerm:title#设置每篇文章对应的 issue 的名字，可选 pathname title url，theme:github-light# theme: photon-dark如果是config.toml或config.yml需要适当调整，我的配置都是单独拆分文件管理的，具体不赘述。\n添加模板文件，layouts\\partials\\comments.html:\n{{- if .Site.Params.utter.repo -}} \u0026lt;div id=\u0026#34;utter-container\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://utteranc.es/client.js\u0026#34; repo= \u0026#39;{{ .Site.Params.utter.repo }}\u0026#39; issue-term= \u0026#34;{{ .Site.Params.utter.issueTerm }}\u0026#34; theme= \u0026#39;{{ .Site.Params.utter.theme }}\u0026#39; crossorigin= \u0026#34;anonymous\u0026#34; async\u0026gt; \u0026lt;/script\u0026gt; {{- end }} 至此完工。\n不过需要注意的是，这里我使用的是文章title作为记录评论的依据，如果title改变将导致原有的评论丢失，不过一般不会修改标题，还有黑白调的切换这里还不能控制，后面再优化吧。\n参考  utteranc.es 给hugo博客添加评论功能  ","permalink":"https://zone.dnfn.tech/post/2a86b000a420f725ee577c52c8e18c0e/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e网站虽小，但评论功能不能少，万一哪天有老哥想跟我唠嗑呢？先用utterances搞个评论功能撑撑场面。\u003c/p\u003e","title":"Hugo 网站评论功能"},{"content":"简介 本文适合对OAuth2已经有一定了解的开发人员，没有说到几种具体的模式流程，仅仅写下我自己对授权oauth2的理解，还有一些疑问和解答，希望对阅读的人有所帮助，如果有什么建议可以直接联系笔者。关于具体的模式讲解和实例我就留到后续文章中一一道来。\n了解授权 什么是授权 简单来说就是将自己的权限给其他人，让他可以完成相应的工作任务。\n这里实际有个主动被动的关系，一般开发中的授权都是说的被动式的（请求用户授予权限）。\n为什么需要授权 互联网作为一个的庞大网络，其中有海量的服务提供方，而我们个人作为这些服务的使用者，通常需要对不同的服务提供相同的信息（比如身份、学历、联系方式等等），而这不就相当于自己把个人信息从一个已有的服务系统拷贝另一个新的服务系统中吗？不想自己做，嫌麻烦了也可以委托其他人来拷贝，但再此之前得找自己信得过帮手让他代替自己（你肯定不希望随便一个陌生人盗用自己得信息），为了不同服务间资源数据的安全共享，所以需要授权！\n怎么授权 注：怎么授权换言之就是授权方式，先思考有哪些授权方式，它们可能会遇到的问题和处理方式，至于它们具体实现细节这里不做过多描述。\n在了解怎么授权的之前，先思考授权这个过程涉及到了哪些角色（自己的理解，比较片面）：\n 用户：资源数据的所有方 服务提供方：需要共享资源数据给外部的服务 服务使用方：第三方服务、外部服务、接入方、调用方  授权行为：用户将自己在服务提供方的权限（部分或全部）给服务使用方，使服务使用方可进行相关权限的操作。\n最简单的授权无非是服务提供方将用户的帐号密码给第三方系统（服务使用方），但这是建立在非常信任情况下（应该没有正常人会把自家大门钥匙给一个从未见面的陌生人吧）\n共享帐号密码实现确实简单直接，但这真的没有弊端吗？\n试想自己作为服务提供方采用这种方案，将会有哪些问题？\n 要是哪天用户的密码换了，又怎么让第三方系统能继续访问资源？（同步帐号密码必然遇到更多问题！） 又或者是哪天第三方其中的一个不再可信，不能再给他权限了，如何保证在不影响用户和其他第三方系统的情况下对其限制？ 再说如果给了帐号密码，就相当于用户在操作，又怎么知道用户是否真的出于意愿来进行操作？（难以保证第三方不会滥用帐号密码） 更需要注意的是权限，比如第三方系统已知用户帐号密码，那他是否可以修改用户的密码？  以上只是想到的一部分问题，估计要解决这些问题又得牺牲为数不多的头发。\n如果站在被授权方（服务使用方）的角度，这些问题都不算事，只要你给密码，我能完成工作，那就没问题！\n但是站在授权方（服务提供方）的角度，那就不得不重视了，不仅是为了用户，也是为了本系统的安全！\n从服务提供方的角度来考虑的话，怎么授权才能避免上面的问题？\n 当然是不与第三方共享密码，或者直接由用户提供帐号密码授权 需要验证第三方服务的身份，不是任何人都可以随便接入授权服务 让用户参与到过程中（提供帐号密码、确认授权范围、确认人为操作）  所以授权是最好三方（服务提供方、服务使用方、用户）一起参与才最真实可靠，简单的说就是\n 不止校验用户是否有意愿来完成授权 还要看服务使用方是否是可信的  以共享用户帐号密码的方式为例，首先只有完全可信的第三方（服务使用方）才能共享帐号密码，但用户是否真的有意愿使用功能那就不得而知了（问题3）。\n那么如何做到这些呢？\n从OAuth2 授权码模式中可以总结出了这样的答案：\n 服务使用方在服务提供方注册自己的身份信息用于验证是否可信（client_id、client_sercet等） 通过重定向页面让用户确认授权信息（用户信息通过用户登录或者已登录的会话获得，从而关联用户信息和服务使用方）  前面说到直接与多个外部系统共享用户帐号密码的方式将面临的问题，正好可以基于以上两点来解决：\n 用户更改密码，并不影响第三方系统（被授权方）在服务提供方已注册的身份信息，两者是独立的 各第三方系统（被授权方）在服务提供方注册的信息也是相互独立的，限制其中一个并不影响其他第三方系统 不止第三方系统，用户也参与了授权（重定向页面验证用户身份） 用户可以根据自己的意愿来确认是否授权（比如授予修改密码的权限）  当然不能避免的是引入需要考虑的新问题：\n 如何避免第三方系统身份信息的泄露、被盗用的情况（类似用户帐号密码泄露的情况） 用户直接参与授权验证，交互会更加复杂，给外部的可乘之机就越多 用户的每次授权的时效性（只有一段时间内可用，避免一次授权一直使用，当然也存在特殊场景） 如何避免用户被钓鱼授权（用户在本系统已登录认证过，然后在互联网点击攻击者放置的钓鱼链接以获取其他正规网站的授权）  等等一系列问题，不过现在不需太过深入在意。\n以上是个人学习OAuth2.0授权码模式同时思考的总结，总而言之授权过程的需要考虑：\n 服务使用方是否是可信的 用户信息是否真实 用户是否有意愿来完成授权 互联网的一些安全问题  注：如果已经了解过OAuth2.0的密码模式，或许会注意到该模式并没有验证服务使用方的信息（client_id、client_sercet等），可以说是从传统的用户帐号密码验证演变来的，能提供帐号密码既是可信的（被盗和泄露另说），官方文档上说明(需保密就用授权码模式)：\n If the client type is confidential or the client was issued client\ncredentials (or assigned other authentication requirements), the\nclient MUST authenticate with the authorization server as described\nin Section 3.2.1.\n OAuth2.0授权 首先，和上面思考怎么授权之前一样，OAuth2.0对涉及的角色给出了相关定义。\n resource owner: 资源拥有者，可以理解成常见的用户。\nclient：客户端，请求被授权的应用。可以理解授权服务的使用方。\nresource server：实际提供资源数据的服务器\nauthorization server: 授权服务器\n 在我的理解中，resource server+authorization server可以合称为服务提供方，因为这两者相对服务使用者来说是一方的。只是这里根据各自的职责定义更加详细具体。\n再看OAuth 2.0的抽象运行流程如下图，摘自RFC 6749。\n\n这个图我在我学习OAuth2.0的整个过程中至少看到过五次，然而就算一遍又一遍其中的每一步的意义，始终感觉自己哪里不明白（不知道有人跟我一样不）\n起初我有些困惑这个图为啥和自己印象中的OAuth2.0授权流程不一样，几经思考还是暂时放在一边\n后来才逐渐反应过来这不过是抽象的授权协议流程（印象中的是几个模式具体的流程）\n但紧接着我又疑惑了：为什么抽象的授权协议流程是这样的？与几个模式具体的流程差异这么大？这样的流程有什么好处？\n抽象的授权流程换言之意味着最符合理想效果的流程，所以我反过来思考什么是理想的授权效果？通常的授权方式又有哪里不尽人意？该怎样授权？\n设想一个情景：找人装修 角色： 1. 我们：高大上小区的物业和门卫 2. 张三：他在我们小区刚买了套新房，平时996 3. 李四：老实巴交专门接私活干的装修工 事件：张三请李四帮他装修房子 星期一早上10点，李四拎着他的麻袋来给张三干活。 我一瞧，这么大一个麻袋干嘛的，难不成是人口贩子？不行，得好好盘问盘问：“你谁？来这干嘛得？”。 李四憨厚一笑道：“我是来装修得，张三请我来的，就是1栋2单元3楼4户的业主”。 1234号业主不刚好是物业上面那户程序猿吗，确实是刚买房子还没装，最近常来物业转悠还算挺熟的，我一皱眉，刚想开口再问时，就见他放下麻袋，抽裤兜里掏出一张对半折的整整齐齐的纸条递给我。 “这是张三他给我的委托书，你给看看呢。”他憨笑着摸了摸后脑勺说到。 我接过纸条展开一看眉头一展，这歪七拐八的字确实是那苦逼程序猿张三的真迹，而且这人老实巴交的看也不像假话。“行吧，这委托书我就收下了，你跟我去物业来办个临时工作证，后面就用它进出吧。” 于是李四老老实实跟着我办了证，天天拿着他的临时出入证勤勤恳恳去帮张三装房子去了。 可以代入不同角色去思考，这里从物业门卫的角度考虑，是为了确保小区内的所有居民的安全，不只是特例张三。\n整理下几者之间是如何交互的：\n 张三、李四早就知道李四是没法直接进小区的，所以张三事先给李四整了一张能证实张三身份并说明李四事由的委托书。 李四将委托书交由交由门卫进行验证真实性，并为其办理临时出入证。 李四使用临时身份证开始自己的工作  当然这里只是举个例子，要是思考：为啥张三不直接带李四一起进去？又或者为啥要整个委托书，不直接电话？\u0026hellip;等等类似问题，那就说明考虑的很全面。不过这里简单抽象就够了（你可以把张三自己看着证明，或者张三的电话回答是证明），到最后也就是上面的OAuth2.0抽象流程图。\n话说回OAuth2.0抽象流程图具体步骤：\nA：Client找Resource Owner要一个凭据，为了完成他委托自己办的事 B：Resource Owner给Client一个凭据，这个凭据同时记录了委托人、被委托人、委托事项等 C：Client将凭据给Authorization server进行验证（这里只是抽象流程，验证真实性的方式不需太过深入） D：Authorization server觉得凭据没啥问题，再给了Client整个临时访问的令牌用 E：Client拿着令牌到Resource server确认，并告知他想干嘛 F：Client完成自己的工作，并从Resource server得到想要的结果数据 这不就像：\n 张三是Resource Owner 李四是Client 物业门卫是Authorization server  或许你会在意Resource server体现在哪，E、F步骤怎么体现？可以理解就是小区门禁。\n这个流程的难点无疑在于B步骤（授权方式）：\n Resource Owner如何授予权限给Client？ Authorization Server如何知道B步骤是真实的？也就是C步骤Client提供的授权凭据是真实的  答案是重定向，也就是OAuth2中说到的引导用户到指定页面（密码、客户端模式下不需要）。\n授权码模式下，Client引导Resource Owner到Authorization Server的授权页面，同时会附带自己的身份信息，而Authorization Server的授权页面还需要知道是谁来赋权，所以通常还需要Resource Owner登录一次（或者从已登录的会话中获取用户信息）来确定。\n从交互上来看，Authorization Server就像是Resource Owner给Client赋予权限这件事的见证者、记录者。以前面的例子来说，就像是：李四拿的委托书新来的门卫不认，需要到物业处申请专门规定的表单，他签字登记身份信息和事由，然后找来张三签字确认授权，并由物业盖章才能证明。\n关于具体的授权方式就这里写就太长了，先留个新坑吧~\n解惑   Q：为什么要分别定义Authorization Server和Resource Server？\n 两者是抽象概念，实际可以是不同服务器，也可以是同一服务器甚至同一服务。抽象主要是依据职责，而且由于微服务和分布式等的概念，单一职责更易于复用，从而达到一个授权服务器发布的授权也可以用于多个资源服务器目的。\n   Q：为什么大量交互都是使用重定向的，而不是后台直接调用接口？\n 首先，后台调用接口方式也是有的，但仅限于Client请求Authorization Server获取Token时（授权码模式下），剩余交互都是通过重定向，为什么如此？为什么在用户确认授权时Authorization Server不直接将Token通过调用接口方式返回给Client，这样不是更简单高效？\n其实原因主要在于Authorization Server可能无法访问Client给的重定向地址，比如不同域下、重定向地址需要当前已登录的用户信息等等。一个简单的例子在局域网内对接外网服务认证（比如Github），或者使用带有localhost的地址作为结果处理端点，这样授权服务器是无法连接客户端的，但是用户代理（通常指浏览器）一定知道，所以重定向更加适用，而且也可减轻授权服务的压力。\n   Q：为什么授权码模式需要有一步Code，再换取Token？\n 与简化模式不同，授权码模式多出一步授权Code请求，而不是直接返回Token，这样做的目的肯定是为了更安全！\n上一个问题说到为什么使用重定向，然而这样也会带来困难，直接返回Token会暴露给外部、甚至攻击者（实际上简化模式就是这样做的，但迫不得已才会采用这种授权方式），所以中间添加了一步Code，但Code就不会暴露吗？会，同样的！但是没关系，因为只拿到Code是没有用的，还得需要一个东西，也就是client_sercet。\n在授权码模式中Client身份实际有两个东西结合认证的：client_id与client_sercet，client_id通过用户代理的url参数早已经暴露在网络中，只能表示是谁，而client_sercet不同，它只有在Client主动调用请求Authorization Server的Token接口时才使用，也就是能使用client_sercet一定是他自己（或者类似集群的），Code结合client_sercet一起使用在授予Token时先确认Client的身份准确无误，这就是Code的意义，确保Token只被对的人获取。\n而在简化模式中不能使用client_sercet(一般没有后端服务程序，但前端传输会暴露，所以不能使用)，这样就不能校验Client的身份，那么Code在简化模式中也就没有意义，还不如直接请求Token来的实在。\n   Q：授权权码模式下，获取Token时redirect_uri需要和获取Code是相同的？\n 一开始我以为两个redirect_uri都会用来重定向，但实际上只有请求Code后才会发生一次重定向(Authorization Server -\u0026gt; Client)，获取Token的接口参数redirect_uri是为了校验前面的请求，保持一致性，防止外部攻击。\n   Q：为什么简化模式不校验client_sercet直接获取到Access token?\n 校验不了，参考问题：为什么授权码模式需要有一步Code，再换取Token？\n更多文章：stackoverflow\n   Q：简化模式的token获取脚本（web-hosted client resource）指的是从授权服务器、Client的Web服务器还是资源服务器?\n 我觉得时Client的Web服务器上的一个脚本，但图例中既有web-hosted client resource又有Client，实在令人混淆，但实际的重定向目标地址时之前Client提供的redirect_uri，也就是Client的资源路径之一（专门用于获取url上hash片段里的Token的页面）。\n更多文章：stackoverflow等。\n   Q：关于参数state有什么意义\n 保持请求设备一致性，也就是防止CSRF攻击，简单的说就是攻击者用他已有的帐号和他的state向授权服务器申请Authorization Grant后，用其伪造一个链接或图片让用户点击，这样用户以为他授权的是自己帐号，但实际是攻击者专门的帐号，之后用户的所有操作都可被攻击者看见，如果向该帐号推送数据（比如保存文件，帐号密码，转账等等），那就完蛋了！所以说对state进行校验是有必要的，要是传出的和传入的state不等，那直接拒绝就完事了!\nstate 如果为固定值的话意义不大，攻击者知道了就形同摆设，最好是动态的（例如会话的hash值）！\n可以从以下文章中了解更多\n 关于 OAuth2.0 安全性你应该要知道的一些事 移花接木：针对OAuth2的CSRF攻击 技术干货 | OAuth2.0的安全解析     Q：资源服务器在接受每个请求时，是怎么判断令牌的真实有效性的？\n 这部分实际不在OAuth2协议规范里。通常验证需要资源服务器与授权服务器交互协调，也可以通过其他方式，例如中间件（Redis）或者JWT实现。\n   Q：认证和授权的区别？\n 二者实际不一样，但又有一定联系，一时间有些混淆。\n认证：辨认证实身份。通常指的是程序和用户二者之间的交互，程序需要知道用户到底是谁？登录认证便是一种。\n授权：授予权限访问。通常指的是三者交互（用户、服务提供方、服务使用方），服务使用方请求用户将他（用户）在服务提供方的部分或全部权限授予自己（服务使用方）。\n区别：认证更倾向于用户是谁！授权更倾向于能替哪个用户干什么事！一般认证后，拥有对整个帐号的功能数据的所有权力，但授权后仅限于被已认证的用户授予的部分。\n联系：授权时一般涉及到用户身份认证。\n   参考  OAuth 2.0 的一个简单解释 - 阮一峰 理解OAuth2.0 - 阮一峰 OAuth 2.0 的四种方式 - 阮一峰 OAuth2.0 详解 - 知乎 The OAuth 2.0 Authorization Framework - rfc6749 从“黑掉Github”学Web安全开发 OAuth 2.0 Tutorial 关于 OAuth2.0 安全性你应该要知道的一些事 - chrisyue 移花接木：针对OAuth2的CSRF攻击 技术干货 | OAuth2.0的安全解析 OAuth2授权码模式详细流程（一）——站在OAuth2设计者的角度来理解code  ","permalink":"https://zone.dnfn.tech/post/202107171742448/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e本文适合对\u003ccode\u003eOAuth2\u003c/code\u003e已经有一定了解的开发人员，没有说到几种具体的模式流程，仅仅写下我自己对授权\u003ccode\u003eoauth2\u003c/code\u003e的理解，还有一些疑问和解答，希望对阅读的人有所帮助，如果有什么建议可以直接联系笔者。关于具体的模式讲解和实例我就留到后续文章中一一道来。\u003c/p\u003e","title":"OAuth2理解和疑惑"},{"content":"简介 本文记录了ThreadGroup的作用和特性，它和线程池的区别。\n前言 同事突然问我线程组ThreadGroup与线程池ThreadPool有什么区别？又有啥作用？\n说实话，确实自己理解的不够清晰，讨论过后整理记录下自己的理解\n各自的意义 字面意义：\n 线程池：空闲的线程放在一起管理 线程组：对线程进行分组管理  从定义上看：\n 线程池是一种池化实现，为了重复利用空闲的线程资源，避免系统频繁创建线程造成的大量资源消耗。 线程组是一个抽象集合，为了统一方便管理多个线程。  当然线程池也可以理解为一类线程的集合，不过这类集合与线程组同样是有区别的：\n 线程池是空闲的线程的集合 线程组是所有活动中的线程和线程组的集合  为什么是所有？\nJVM启动时会创建一个名为system的线程组，它并没有parent对象。\n/** * Creates an empty Thread group that is not in any Thread group. * This method is used to create the system Thread group. */ private ThreadGroup() { // called from C code  this.name = \u0026#34;system\u0026#34;;  this.maxPriority = Thread.MAX_PRIORITY; this.parent = null; } 而在JVM启动完成后，程序运行时创建的ThreadGroup会放入当前线程所在的线程组，这意味着之后的线程都有一个parent对象。\npublic ThreadGroup(String name) { this(Thread.currentThread().getThreadGroup(), name); } public ThreadGroup(ThreadGroup parent, String name) { this(checkParentAccess(parent), parent, name); } private ThreadGroup(Void unused, ThreadGroup parent, String name) { this.name = name; this.maxPriority = parent.maxPriority; this.daemon = parent.daemon; this.parent = parent; parent.add(this); } 而创建Thread时，默认会加入当前线程所在的线程组。\nprivate Thread(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { // ...  if (g == null) { if (security != null) { /* security.getThreadGroup()方法用于在被调用期间返回要在其中创建任何新线程的线程组，否则，当在调用期间没有与其相关的新创建线程时，它将返回当前线程的线程组 */ g = security.getThreadGroup(); } /* 默认加入父线程所在的线程组 */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); // ...  g.addUnstarted(); this.group = g; // ... } 由此可见JVM启动时会创建一个默认名为system的线程组，由这个线程组一直往下创建Thread和ThreadGroup，能够想象这形成的是一个树结构，根节点便是这个system的线程组。\n\n为什么时活动中?\n线程只有执行start时才会加入ThreadGroup，而当其退出则会被移出。\n// Thread.class public synchronized void start() { /** * This method is not invoked for the main method thread or \u0026#34;system\u0026#34; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \u0026#34;NEW\u0026#34;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group\u0026#39;s list of threads * and the group\u0026#39;s unstarted count can be decremented. */ group.add(this);  boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this);  } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } // Thread.class private void exit() { if (threadLocals != null \u0026amp;\u0026amp; TerminatingThreadLocal.REGISTRY.isPresent()) { TerminatingThreadLocal.threadTerminated(); } if (group != null) { group.threadTerminated(this);  group = null; } /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; } // ThreadGroup.class void threadStartFailed(Thread t) { synchronized(this) { remove(t);  nUnstartedThreads++; } } void threadTerminated(Thread t) { synchronized (this) { remove(t);  if (nthreads == 0) { notifyAll(); } if (daemon \u0026amp;\u0026amp; (nthreads == 0) \u0026amp;\u0026amp; (nUnstartedThreads == 0) \u0026amp;\u0026amp; (ngroups == 0)) { destroy(); } } } 各自的作用 线程池的作用上面已经说过了，是为了减小系统频繁创建线程带来的资源消耗，而线程组为了统一方便的管理组内多个线程提供很多方法：\n   返回类型 方法 描述     void suspend() 暂停所有线程   void resume() 恢复所有线程   void stop() 停止所有线程   void interrupt() 中断所有线程   void setMaxPriority(int pri) 设置最大优先级     注： 由于线程安全问题，suspend()、resume() 和 stop() 都已经被标记过时了。\n Thread.stop可能导致数据不一致问题被弃用\nThread.suspend和Thread.resume也容易导致死锁\n上面的方法都是批量修改管理线程的，ThreadGroup还提供了许多查看状态的方法\nint activeCount() // 返回此线程组及其子组中活动线程数的估计值 int activeGroupCount() //返回此线程组及其子组中活动线程组数的估计值 int enumerate(Thread[] list) // 将此线程组及其子组中的每个活动线程复制到指定的数组中 int enumerate(Thread[] list, boolean recurse) // 将此线程组及其子组中的每个活动线程复制到指定的数组中 int enumerate(ThreadGroup[] list) // 将此线程组及其子组中的每个活动线程组复制到指定的数组中 int enumerate(ThreadGroup[] list, boolean recurse) // 将此线程组及其子组中的每个活动线程组复制到指定的数组中 void list() // 将有关此线程组的信息打印到标准输出。 字段属性 public class ThreadGroup implements UncaughtExceptionHandler { // 父线程组对象  private final ThreadGroup parent; // 线程组名  String name; // 最高优先级  int maxPriority; // 是否已销毁  boolean destroyed; // 是否守护线程组  boolean daemon; // 虚拟机自动挂起  boolean vmAllowSuspension; // 未启动的线程数量  int nUnstartedThreads; // 已启动的线程总数  int nthreads; // 已启动的线程数组  Thread[] threads; // 线程组总数  int ngroups; // 线程组数组  ThreadGroup[] groups; // ... methods } 其中：\n maxPriority不能大于parent.maxPriority，根线程组的maxPriority为 10 还存在运行中的线程时无法调用destroy，无法销毁，销毁是递归的 daemon表示为守护线程组，与线程的daemon无关，详见 守护线程组 new Thread(...)就会使nUnstartedThreads++ nthreads是threads的最后一个元素的下标，当Thread.start()时加一，并可触发扩容 threads和groups初始容量为4，2倍数扩大  守护线程组 ThreadGroup和Thread都有daemon属性，ThreadGroup又可以统一管理Thread，很容易让人认为ThreadGroup.setDaemon(boolean)也是循环遍历设置Thread.daemon，然而并不是这样（之前理解错了 😂）。\n在ThreadGroup.setDaemon(boolean)源码上有一段说明：\n/** * Changes the daemon status of this thread group. * \u0026lt;p\u0026gt; * First, the {@code checkAccess} method of this thread group is * called with no arguments; this may result in a security exception. * \u0026lt;p\u0026gt; * A daemon thread group is automatically destroyed when its last * thread is stopped or its last thread group is destroyed. * * @param daemon if {@code true}, marks this thread group as * a daemon thread group; otherwise, marks this * thread group as normal. * @throws SecurityException if the current thread cannot modify * this thread group. * @see java.lang.SecurityException * @see java.lang.ThreadGroup#checkAccess() * @since 1.0 */ public final void setDaemon(boolean daemon) { checkAccess(); this.daemon = daemon; } 大致意义就是线程组的daemon属性表示当它内部没有active的线程时，它会自动销毁。\n当一个守护线程组ThreadGroup不存在活动中的线程或者子线程组时，它会执行销毁方法destroy:\nprivate void remove(ThreadGroup var1) { synchronized(this) { if (!this.destroyed) { for(int var3 = 0; var3 \u0026lt; this.ngroups; ++var3) { if (this.groups[var3] == var1) { --this.ngroups; System.arraycopy(this.groups, var3 + 1, this.groups, var3, this.ngroups - var3); this.groups[this.ngroups] = null; break; } } if (this.nthreads == 0) { this.notifyAll(); } if (this.daemon \u0026amp;\u0026amp; this.nthreads == 0 \u0026amp;\u0026amp; this.nUnstartedThreads == 0 \u0026amp;\u0026amp; this.ngroups == 0) { this.destroy();  } } } } void threadTerminated(Thread t) { synchronized (this) { remove(t); if (nthreads == 0) { notifyAll(); } if (daemon \u0026amp;\u0026amp; (nthreads == 0) \u0026amp;\u0026amp; (nUnstartedThreads == 0) \u0026amp;\u0026amp; (ngroups == 0)) { destroy();  } } } 相关 ThreadGroup in Java\nJava 并发 之 线程组 ThreadGroup 介绍\nJava多线程系列——过期的suspend()挂起、resume()继续执行线程\nThreadGroup\n","permalink":"https://zone.dnfn.tech/post/2021062424104134/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e本文记录了\u003ccode\u003eThreadGroup\u003c/code\u003e的作用和特性，它和线程池的区别。\u003c/p\u003e","title":"ThreadGroup 线程池"},{"content":"简介 主要记录了使用 spring 重定向时遇到的问题，以及重新熟悉 HTTP 3xx 中重定向状态码的意义。\n前言 最近接手的一个项目需要在 POST 接口中处理逻辑，完成后让浏览器重定向到首页，请求方式需要变成 GET 。\n结果一直提示 405 方法不支持。折腾了个把都没找到问题原因，没想到是重定向的状态码有问题。\n问题 一般情况下，在 Spring下重定向到页面时会使用 ModelAndView，也就是这样：\n@PostMapping(\u0026#34;handle\u0026#34;) public String handle(){ // do something ...  return \u0026#34;redirect:/\u0026#34;; } 这种类似的情况下返回的是：\nPOST http://localhost:8080/tdh-portal/cas HTTP/1.1 302 Found Content-Language: zh-CN Location: http://localhost:8080/ Content-Length: 0 Server: Jetty(9.4.z-SNAPSHOT) \u0026lt;Response body is empty\u0026gt; Response code: 302 (Found); Time: 119ms; Content length: 0 bytes 也不知道从哪里复制了一段代码 😂 ，主要部分如下：\n@PostMapping(\u0026#34;handle\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handle(){ // do something ...  return ResponseEntity .status(HttpStatus.TEMPORARY_REDIRECT) .header(HttpHeaders.LOCATION, \u0026#34;/\u0026#34;) .build(); } 响应信息则是这样\nPOST http://localhost:8080/handle HTTP/1.1 307 Temporary Redirect Set-Cookie: JSESSIONID=node0123krmz4upibb18jz7ov4us1pw1.node0;Path=/ Expires: Thu, 01 Jan 1970 00:00:00 GMT Location: / Content-Length: 0 Server: Jetty(9.4.z-SNAPSHOT) \u0026lt;Response body is empty\u0026gt; Response code: 307 (Temporary Redirect); Time: 4916ms; Content length: 0 bytes 可以看到两种方式主要响应码不同 302 与 307。经过查阅相关文档发现意义大不相同：\n   编码 含义 处理方法     302 Found GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。1   307 Temporary Redirect 方法和消息主体都不发生变化。    典型应用场景：\n302：由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。\n307：由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。\n302 与 307 最主要的不同点在于方法和消息体是否发生变化。所以导致用POST方法请求接口时无法重定向到使用GET方法的页面。\n经过查看重定向相关的响应码规范，修改代码：\n@PostMapping(\u0026#34;handle\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handle(){ // do something ...  return ResponseEntity .status(HttpStatus.SEE_OTHER) .header(HttpHeaders.LOCATION, \u0026#34;/\u0026#34;) .build(); } 这里使用 303 主要是为了验证成功跳转防止重复触发。\nHTTP 的重定向  不同类型的重定向映射可以划分为三个类别：\n 永久重定向 临时重定向 特殊重定向   永久重定向意味着原来的URL不应再被使用，而应优选用新的URL，这种关系是永久性的，通常应用于网站重构,301,308。\n临时重定向顾名思义这种关系是临时性的，有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问,302,303,307。\n特殊重定向是指 300 和 304，不同于其他方式直接给定url跳转重定向，没有特定的处理方式，也可能返回多个能重定向的url供手动选择。\n常见重定向响应码：\n   编码 含义 说明     300 Multiple Choice 不常用：所有的选项在消息主体的 HTML 页面中列出。   301 Moved Permanently GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。2   302 Found GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。3   303 See Other GET 方法不会发生变更，其他方法会变更为 GET 方法（消息主体会丢失）。   304 Not Modified 发送用于重新验证的条件请求。表示缓存的响应仍然是新鲜的并且可以使用。   307 Temporary Redirect 方法和消息主体都不发生变化。   308 Permanent Redirect 方法和消息主体都不发生变化。    延伸  HTTP 的重定向    该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 308 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://zone.dnfn.tech/post/202106161641333/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e主要记录了使用 \u003ccode\u003espring\u003c/code\u003e 重定向时遇到的问题，以及重新熟悉 \u003ccode\u003eHTTP\u003c/code\u003e \u003ccode\u003e3xx\u003c/code\u003e 中重定向状态码的意义。\u003c/p\u003e","title":"Spring POST重定向到GET"},{"content":"简介  .java 文件编译后的 .class 文件内容究竟是怎样的？JVM 又是如果识别并加载 .class 文件的。\n环境 Win10、Nixos\nJDK1.8\nClass文件内容 windows 下用 Powershell 查看字节码内容(十六进制)\nPS\u0026gt; cat Demo.java; public class Demo{} PS\u0026gt; javac.exe Demo.java; Format-Hex Demo.class Path: D:\\tmp\\java\\Demo.class 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000 CA FE BA BE 00 00 00 34 00 0D 0A 00 03 00 0A 07 Êþº¾...4........ 00000010 00 0B 07 00 0C 01 00 06 3C 69 6E 69 74 3E 01 00 ........\u0026lt;init\u0026gt;.. 00000020 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 .()V...Code...Li 00000030 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 0A neNumberTable... 00000040 53 6F 75 72 63 65 46 69 6C 65 01 00 09 44 65 6D SourceFile...Dem 00000050 6F 2E 6A 61 76 61 0C 00 04 00 05 01 00 04 44 65 o.java........De 00000060 6D 6F 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F mo...java/lang/O 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 00000080 01 00 01 00 04 00 05 00 01 00 06 00 00 00 1D 00 ................ 00000090 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 .......*·..±.... 000000A0 00 07 00 00 00 06 00 01 00 00 00 01 00 01 00 08 ................ 000000B0 00 00 00 02 00 09 ...... Linux 下命令行查看\n$ cat IDemo.java public interface IDemo{} $ javac IDemo.java ; hexdump IDemo.class 0000000 feca beba 0000 3400 0700 0007 0705 0600 0000010 0001 530a 756f 6372 4665 6c69 0165 0a00 0000020 4449 6d65 2e6f 616a 6176 0001 4905 6544 0000030 6f6d 0001 6a10 7661 2f61 616c 676e 4f2f 0000040 6a62 6365 0674 0001 0001 0002 0000 0000 0000050 0000 0001 0003 0000 0002 0004 000005b 这里大小端是相反的。\nClass文件结构 一个完整的 class 文件大致可分为10个部分\n 魔数 版本号 常量池\n3.1 常量池计数器\n3.2 常量池数据区 访问标志 类索引 父类索引 接口\n7.1 接口计数器\n7.2 接口信息区 字段\n8.1 字段计数器\n8.2 字段信息区 方法\n9.1 方法计数器\n9.2 方法信息区 属性\n10.1 属性计数器\n10.2 属性信息区  关于class 文件的基本数据结构在 The Java Virtual Machine Specification (Second ed.)文档有详细的说明，如下:\nstruct Class_File_Format { u4 magic_number; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count - 1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } u4: 指4个字节的无符号整型\nu2: 指2个字节的无符号整型\n而cp_info、field_info、method_info、attribute_info 表示相关数据结构，长度均不定可变\nmagic_number 魔数(magic_number)是指某一文件格式下前几个固定字节值，一般用于识别文件格式，class文件的魔数固定为前4个字节，即：CA FE BA BE。\n至于它的来源和背后的故事可以看看 Wiki - Java class file 下的 Magic Number\nminor_version,major_version minor_version,major_version统称版本号，共占用4个字节，各分为2个字节的次版本号(minor_version)占第5、6字节位以及占第7、8字节位的主版本号(major_version)。版本号的作用为标识 class 文件是在具体哪个版本的 JVM 下生成的，让运行时环境的JVM确认是否可以加载此版本的class文件。\n以下常见主版本号(major_version)\n Java SE 17 = 61 (0x3D hex),\nJava SE 16 = 60 (0x3C hex),\nJava SE 15 = 59 (0x3B hex),\nJava SE 14 = 58 (0x3A hex),\nJava SE 13 = 57 (0x39 hex),\nJava SE 12 = 56 (0x38 hex),\nJava SE 11 = 55 (0x37 hex),\nJava SE 10 = 54 (0x36 hex),\nJava SE 9 = 53 (0x35 hex),\nJava SE 8 = 52 (0x34 hex),\nJava SE 7 = 51 (0x33 hex),\nJava SE 6.0 = 50 (0x32 hex),\nJava SE 5.0 = 49 (0x31 hex),\nJDK 1.4 = 48 (0x30 hex),\nJDK 1.3 = 47 (0x2F hex),\nJDK 1.2 = 46 (0x2E hex),\nJDK 1.1 = 45 (0x2D hex).\n 常量池 常量池分为两个数据字段：constant_pool_count(计数器)+constant_pool(数据结构数组)。存储了整个class文件下的字面量信息1，包括：各类型的数字、字符串、类引用、方法引用、字段引用和方法句柄等其他常量。\nconstant_pool_count 常量池计数器（实际并不是数量），它的值：constant_pool_count = constant_pool实体的数量 + 1，这一点与其他的池不同，constant_pool的索引在(0,constant_pool_count)之间（不包含）。总共占2个无符号字节。数值0表示为未引用任何对象。\n以前面win下的例子来说：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000 CA FE BA BE 00 00 00 34 00 0D 0A 00 03 00 0A 07 Êþº¾...4........ 00 0D也就是13，但常量池数量需要减1，所以是12。\nconstant_pool constant_pool_count只是常量池的计数器，实际数据在constant_pool数组中。constant_pool也就是实际意义上的常量池，长度不定。数组中每一个元素数据结构为：\ncp_info { u1 tag; u1 info[]; }  tag：常量的类型 info：常量信息  常量信息info是一个不确定数组，不同的tag也就是常量类型，info数组长度是不一样，每个常量类型的info都是固定的或可计算的，而对于字符串等不定长的结构，通常都是采取分为两个字段表示（实际上池也是）：一个长度，一个数组。\n相关的tag类型:\n\n需要注意的几个结构：\n因为在class文件中，大多数信息最终都会用字符串内容表示，所以字符串内容无疑是最基本的结构之一。\nCONSTANT_Utf8_info { u1 tag; u2 length; u1 bytes[length]; } CONSTANT_Utf8_info 也就是我们常说的字符串常量（utf8编码过后的内容），它在tag之后的两个字节为无符号数值，它表示了这个字符串的UTF-8编码后的字节数组长度，即bytes的大小。这里不深入bytes存储的具体内容和方式，详细可查看原文档。\n然后是CONSTANT_String_info：\nCONSTANT_String_info { u1 tag; u2 string_index; } CONSTANT_Utf8_info用来表示常量字符串的内容，而CONSTANT_String_info则表示常量字符串对象，即为产生的Object。对象的实际内容通过string_index指向实际的CONSTANT_Utf8_info。\n常量池中大多数都是依赖一个index指向实际的CONSTANT_Utf8_info来表示（数值直接通过字节表示）。\n例如，类：\nCONSTANT_Class_info { u1 tag; u2 name_index; } name_index实际就是一个CONSTANT_Utf8_info的索引。\n再比如，方法、字段等：\nCONSTANT_Fieldref_info { u1 tag; u2 class_index; u2 name_and_type_index; } CONSTANT_Methodref_info { u1 tag; u2 class_index; u2 name_and_type_index; } CONSTANT_InterfaceMethodref_info { u1 tag; u2 class_index; u2 name_and_type_index; } 这里的class_index指的是constant_pool中一个具体的CONSTANT_Class_info的索引，而name_and_type_index指的其中具体某一个CONSTANT_NameAndType_info，其结构如下：\nCONSTANT_NameAndType_info { u1 tag; u2 name_index; u2 descriptor_index; } 它包含的name_index和descriptor_index是两个CONSTANT_Utf8_info在常量池的索引。\n以前面win下的例子来看：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000 CA FE BA BE 00 00 00 34 00 0D 0A 00 03 00 0A 07 Êþº¾...4........ 00000010 00 0B 07 00 0C 01 00 06 3C 69 6E 69 74 3E 01 00 ........\u0026lt;init\u0026gt;.. 00000020 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 .()V...Code...Li 00000030 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 0A neNumberTable... 00000040 53 6F 75 72 63 65 46 69 6C 65 01 00 09 44 65 6D SourceFile...Dem 00000050 6F 2E 6A 61 76 61 0C 00 04 00 05 01 00 04 44 65 o.java........De 00000060 6D 6F 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F mo...java/lang/O 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 共计12个常量，简单说明几个：\n第1个：0A 00 03 00 0A，tag：0A(CONSTANT_Methodref_info)，info[4]：00 03 00 0A。\nCONSTANT_Methodref_info { u1 tag; // `0A`  u2 class_index; // `00 03`  u2 name_and_type_index; // `00 0A` } 第3个：07 00 0C\nCONSTANT_Class_info { u1 tag; // 07  u2 name_index; // 00 0C } 第10个：0C 00 04 00 05\nCONSTANT_NameAndType_info { u1 tag; // 0C  u2 name_index; // 00 04  u2 descriptor_index; //00 05 } 第12个：01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74\nCONSTANT_Utf8_info { u1 tag; // 01  u2 length; // 00 10  u1 bytes[length]; // 6A 61 76 61 2F 6C 61 6E 67 2Fj 4F 62 6A 65 63 74 } 这里直接通过 javap 查看class文件的编译字节信息\nPS\u0026gt; javap -v Demo.class Classfile D:\\tmp\\java\\Demo.class Last modified 2021-6-19; size 182 bytes MD5 checksum 626255e824a12d768af074fcb588b1d3 Compiled from \u0026#34;Demo.java\u0026#34; public class Demo minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER Constant pool: #1 = Methodref #3.#10 // java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #2 = Class #11 // Demo #3 = Class #12 // java/lang/Object #4 = Utf8 \u0026lt;init\u0026gt; #5 = Utf8 ()V #6 = Utf8 Code #7 = Utf8 LineNumberTable #8 = Utf8 SourceFile #9 = Utf8 Demo.java #10 = NameAndType #4:#5 // \u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V #11 = Utf8 Demo #12 = Utf8 java/lang/Object { public Demo(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:()V 4: return LineNumberTable: line 1: 0 } SourceFile: \u0026#34;Demo.java\u0026#34; 第12个常量对应java/lang/Object，第4和5个常量为\u0026lt;init\u0026gt;和()V，所以第一个变量是java/lang/Object.\u0026quot;\u0026lt;init\u0026gt;\u0026quot;:()V，实际指向类Object编译的初始化方法\u0026lt;init\u0026gt;。\n接口常量就更加少了，这里不再继续说明了。\naccess_flags access_flags为访问标志，共2个字节，用于表示某个类或者接口的访问权限及基础属性。\n详细内容可查看《Java虚拟机原理图解》 1.1、class文件基本组织结构。\n\n以前面的例子来看：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 即：ACC_SUPER+ACC_PUBLIC\nthis_class 当前类索引，即当前类或者接口在constant_pool中的位置索引。\n以之前的例子来看：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 00 02即是第2个，参见上文。\nsuper_class 父类索引，即当前类的父类在constant_pool中的索引。\n以之前的例子来看：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 父类为第3个常量class，也就是Object。\n对于Object(没有父类)，则索引为0。\n对于接口：\n00000040 65 63 74 06 01 00 01 00 02 00 00 00 00 00 00 00 ect............. // javap -v Demo.class #2 = Class #6 // java/lang/Object 只能是Object。\n接口表 interfaces_count 接口计数器，占两个字节，interfaces_count的值表示当前类或接口的直接父接口数量。可为0。\ninterfaces 接口数组，长度为interfaces_count。数组中每一个元素必须是constant_pool中的一个CONSANT_Class_info常量。存储顺序与代码中提供的接口顺序相同。\n上文无接口时，表示为\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 只有接口计数器的值00 00\n字段表 字段表同样由两个部分组成：fields_count和fields。\nfields_count 字段计数器，共2个字节，表示当前Class文件fields数组的长度。可以为0。\nfields 字段数组，字节大小不定，元素结构为field_info，长度为fields_count。只包含当前class文件定义的字段，继承的部分不在其中。\nfield_info结构：\nfield_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; } 其中name_index和descriptor_index都是constant_pool的一个CONSTANT_Utf8_info索引。\nattributes结构与class文件的attributes结构一致，后文再讲。\n当fields_count为0时，和接口表一样不会有数据区fields:\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 方法表 方法表同样分为两个部分：methods_count和methods\nmethods_count 方法计数器，共占用两个字节，从0开始，表示当前class文件定义的方法数量，不包含继承的部分。\n上文的例子中表示的位置：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 00000080 01 00 01 00 04 00 05 00 01 00 06 00 00 00 1D 00 ................ 只有一个方法。\nmethods 方法数组，长度不定，每个元素均为method_info。\nmethod_info数据结构：\nmethod_info { u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count]; } 和字段表元素结构类似，name_index和descriptor_index均是constant_pool中的一个CONSTANT_Utf8_info常量的索引。\n以上文的例子数据来看：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000080 01 00 01 00 04 00 05 00 01 00 06 00 00 00 1D 00 ................ 这里共8个字节，不包含attributes，相关常量查看上文:\n 00 01: access_flags，访问标志：ACC_PUBLIC 00 04: name_index，方法名，常量表里的 \u0026lt;init\u0026gt; 00 05: descriptor_index，方法描述，常量表里的 ()V 00 01: attributes_count，方法属性个数，1个  方法的属性同类属性一起。\n属性表 属性表同样也是两个部分组成：attributes_count和attributes\nattributes_count 属性计数器，共占2个字节，表示attributes数组元素的个数。\nattributes 属性数组，大小不定，长度为attributes_count，每个元素的结构都是attribute_info，字段、方法、class文件都会用到。\nattribute_info数据结构：\nattribute_info { u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length]; } 其中attribute_name_index表示的是属性名，其值为常量池constant_pool中的一个CONSTANT_Utf8_info常量的索引，属性内容长度用了4个字节表示。\nclass文件五个非常重要的属性：\n ConstantValue Code StackMapTable Exceptions BootstrapMethods  详细属性可在官网了解，这里只简单说明下\nCode是method_info的一个属性，它包含方法体内容，其结构为\nCode_attribute { u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count]; } 方法体为code_length+code[code_length]，其他不再细说。\n根据上文仅有的方法来看，它只有一个属性，也就是\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000080 01 00 01 00 04 00 05 00 01 00 06 00 00 00 1D 00 ................ 00000090 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 .......*·..±.... 000000A0 00 07 00 00 00 06 00 01 00 00 00 01 00 01 00 08 ................ 000000B0 00 00 00 02 00 09 ...... 常量表见上文\n 00 06: 属性名索引，值为Code 00 00 00 00 1D: 属性内容长度，值为30个字节  内容根据Code_attribute的数据结构解析\nmax_stack：00 01\nmax_locals：00 01\ncode_length：00 00 00 05\ncode[code_length]：2A B7 00 01 B1\nexception_table_length：00 00\nexception_table： 无\nattributes_count：00 01\nattributes：00 07 00 00 00 06 00 01 00 00 00 01 00\nCode中的attributes还有一个00 07表示的一个LineNumberTable，这里不做说明\n剩下的字节也就是class文件的属性：\n00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 000000A0 00 07 00 00 00 06 00 01 00 00 00 01 00 01 00 08 ................ 000000B0 00 00 00 02 00 09 ...... 这里表示的是SourceFile属性，其值为Demo.java\n思考  Q：导入的静态方法是怎么表示的？\n如果代码里没有用到，编译后会被优化。import的类和方法都会放入constant_pool中作为常量。  延伸  Class 文件基本组织结构 Java class file - Wiki The class File Format    一般描述为固定不变的值\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://zone.dnfn.tech/post/20210608875210/","summary":"\u003c!-- TOC off --\u003e\n\u003ch2 id=\"简介----omit-in-toc---\"\u003e简介 \u003c!-- omit in toc --\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.java\u003c/code\u003e 文件编译后的 \u003ccode\u003e.class\u003c/code\u003e 文件内容究竟是怎样的？\u003ccode\u003eJVM\u003c/code\u003e 又是如果识别并加载 \u003ccode\u003e.class\u003c/code\u003e 文件的。\u003c/p\u003e","title":"Java Class 文件解析"},{"content":"","permalink":"https://zone.dnfn.tech/photo/","summary":"","title":"相册"},{"content":"Java开发程序猿一枚，18年开始工作，毕业于成都信息工程大学，喜好打打游戏，看看风景。\n这里还是一片荒芜。\n","permalink":"https://zone.dnfn.tech/about/","summary":"","title":"博主"},{"content":"简介 这是我的第一篇博客，这篇文章主要讲述了我搭建个人网站，以及如何自动构建发布静态页面的过程。\n前言 最近正好整理记录的笔记，之前写的比较随意，不太好整理，而且之前早就想搭建自己的个人博客网站，正好这次刚好又时间折腾折腾。\n搭建静态网站的框架网上比较多，文档和教程大部分也比较全，这次就直接选择口碑比较好也容易的 Hugo 在 Github 下搭建一个。\n安装 Hugo 在 Win10 下使用命令安装：\nscoop install hugo 验证安装:\nhugo version 这里的Scoop是 Win10 平台下的软件包管理工具之一，非常方便，感兴趣可在 GitHub或CodeChina 上查看。\n更多的安装方式和文档可以参看Hugo 官方安装教程.\n新建站点 新建站点项目\nhugo new site tech-blog Congratulations! Your new Hugo site is created in D:\\tech-blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 配置一款主题\nHugo主题提供了大量模板，这里用的主题是 PaperMod，详细文档(安装、配置)可以在Github上查看。\n更多的主题可以在 Hugo 主题 上查看\ncd tech-blog git init git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive 修改配置文件 config.toml 或者 config.yaml，.toml格式配置可参考官方文档，.\\config.yaml基本内容如下\nbaseurl:\u0026#34;http://zone.desiyonan.tech\u0026#34;title:\u0026#34;DnF\u0026#39;s Zone\u0026#34;defaultContentLanguage:zhhasCJKLanguage:truetheme:PaperMod# 主题params:AuthorName:\u0026#34;DnF\u0026#34;GitHubUser:\u0026#34;desiyonan\u0026#34;启动本地服务器\nhugo server -D Start building sites … | EN -------------------+----- Pages | 12 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 2 Sitemaps | 1 Cleaned | 0 Built in 35 ms Watching for changes in D:\\tech-blog\\{archetypes，content，data，layouts，static，themes} Watching for config changes in D:\\tech-blog\\config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 现在可以直接访问 http://localhost:1313/ 查看站点，不过要看文章具体效果可以先新建测试文章\nhugo new post/test.md \u0026#39;## Test\u0026#39; | out-file -a -e utf8 .\\content\\post\\test.md 访问 http://localhost:1313/post/test 就可以看到测试效果\n最后基本仓库的初始化\ngit commit -am \u0026#34;init\u0026#34; git push -u origin master 配置 Github Pages 基本框架已经搭建完成，需要能够在公网直接访问网页还需要配置 Github Pages。\n看了网上不少的博客，大部分都是在本地编辑 .md 文档，完成后通过 hugo 命令构建输出，最后再把输出的 public 目录推送到 Github 上。\n再尝试了一两次后太繁琐了，而且也不是我想要的效果，最后在知乎上看到最理想的效果：在本地编辑 .md 文档后推送到直接仓库后就可以通过公网看到效果。详细可以看知乎上的文章，说明的很清楚，重复的字也懒得码了，这里简单说明下大致流程和需要注意的地方。\n流程的大致原理:\n简单的说就是：\n 建两个仓库: 一个放文档源码，一个放构建后的页面代码 给源码仓库添加 Action，当推送 master 代码时自动构建页面，再推送到页面仓库  需要注意：\n 放构建后的静态页面的仓库需要配置 Github Pages 两个仓库需要一对 SSH 密钥，源码仓库配置私钥，页面仓库配置公钥 Github Action配置需要根据实际情况改动下  以下是我的改动后 Action 配置内容\nname:Deploy Hugo Site to Github Pages on Master Branchon:push:branches:- masterjobs:build-deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v1 # v2 does not have submodules option nowwith:submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.83.1\u0026#39;extended:true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}# 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名external_repository:desiyonan/zone# Pages 远程仓库publish_dir:\u0026#34;public\u0026#34;keep_files:false# remove existing filespublish_branch:master # deploying branchcommit_message:${{ github.event.head_commit.message }}不同的点：\nwith:submodules:true因为之前配置主题时是到了 git submodule，所以这里必要有，不然构建后没有主题。\n其次\nexternal_repository:desiyonan/zone# Pages 远程仓库publish_dir:\u0026#34;public\u0026#34;external_repository 是放页面仓库，publish_dir 是构建后需要推送的目录，hugo 默认的构建目录就是 public，具体配置看下 config.toml 或者 config.yaml 下有没有\npublishdir:xxxx不复杂，摸索个把小时就行了。两个仓库的关联配置到此位置，还需要最后一步配置页面仓库的Github Pages\n打开对应 Github 仓库页面，找到 Setting 页签，然后可以在侧边栏看到 Pages 设置\n需要配置的主要是 Source 选择分支和目录，自定义域名可以通过 Custom domain 配置，域名配置不是必须，如果配置了还需要新增 static/CNAME 文件，文件内容就是自定义的域名，中途改了几次域名就是没改文件导致访问不了网站。\nPS\u0026gt;cat static\\CNAME zone.desiyonan.tech 至此，耗时两天，一个完整的自动化部署个人博客终于搭建完了，网站的美化后面再一步步来。\n相关链接  Hugo homepage Hugo Install Hugo Docs Hugo Themes Theme PaperMod PaperMod - Github Hugo Config Scoop Github Scoop Codechina Hugo Gitee - Blog 使用Hugo搭建博客 - Blog Hugo Deploy Action  ","permalink":"https://zone.dnfn.tech/post/8df2adb7809b41c597eb2efb10ed66db/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e这是我的第一篇博客，这篇文章主要讲述了我搭建个人网站，以及如何自动构建发布静态页面的过程。\u003c/p\u003e","title":"Hugo+Github 搭建个人网站"}]
[{"content":"简介 记录下授权oauth2的理解，还有自己的疑问等等。\n了解授权 什么是授权 简单来说就是将自己的权限给其他人，让他可以完成相应的工作任务。\n为什么需要授权 互联网作为一个的庞大网络，其中有海量的服务提供方，而我们个人作为这些服务的使用者，通常需要对不同的服务提供相同的信息（比如身份、学历、联系方式等等），而这不就相当于自己把个人信息从一个已有的服务系统拷贝另一个新的服务系统中吗？不想自己做，嫌麻烦了也可以委托其他人来拷贝，但再此之前得找自己信得过帮手让他代替自己（你肯定不希望随便一个陌生人盗用自己得信息），为了不同服务间资源数据的安全共享，这就需要授权！\n怎么授权 注：怎么授权换言之就是授权方式，先思考有哪些授权方式，它们可能会遇到的问题和处理方式，至于它们具体实现细节这里不做过多描述。\n在了解怎么授权的之前，先思考授权这个过程涉及到了哪些角色（自己的理解，比较片面）：\n 用户：资源数据的所有方 服务提供方：需要共享资源数据给外部的服务 服务使用方：第三方服务、外部服务、接入方、调用方  授权行为：用户将自己在服务提供方的权限（部分或全部）给服务使用方，使服务使用方可进行相关权限的操作。\n最简单的授权无非是服务提供方将用户的帐号密码给第三方系统（服务使用方），但这是建立在非常信任情况下（应该没有正常人会把自家大门钥匙给一个从未见面的陌生人吧）\n共享帐号密码实现确实简单直接，但这真的没有弊端吗？\n试想自己作为服务提供方采用这种方案，将会有哪些问题？\n 要是哪天用户的密码换了，又怎么让第三方系统能继续访问资源？（同步帐号密码必然遇到更多问题！） 又或者是哪天第三方其中的一个不再可信，不能再给他权限了，如何保证在不影响用户和其他第三方系统的情况下对其限制？ 再说如果给了帐号密码，就相当于用户在操作，又怎么知道用户是否真的出于意愿来进行操作？（难以保证第三方不会滥用帐号密码） 更需要注意的是权限，比如第三方系统已知用户帐号密码，那他是否可以修改用户的密码？  以上只是想到的一部分问题，估计要解决这些问题又得牺牲为数不多的头发。\n如果站在被授权方（服务使用方）的角度，这些问题都不算事，只要你给密码，我能完成工作，那就没问题！\n但是站在授权方（服务提供方）的角度，那就不得不重视了，不仅是为了用户，也是为了本系统的安全！\n从服务提供方的角度来考虑的话，怎么授权才能避免上面的问题？\n 当然是不与第三方共享密码，或者直接由用户提供帐号密码授权 需要验证第三方服务的身份，不是任何人都可以随便接入授权服务 让用户参与到过程中（提供帐号密码、确认授权范围、确认人为操作）  所以授权是最好三方（服务提供方、服务使用方、用户）一起参与才最真实可靠，简单的说就是\n 不止校验用户是否有意愿来完成授权 还要看服务使用方是否是可信的  以共享用户帐号密码的方式为例，首先只有完全可信的第三方（服务使用方）才能共享帐号密码，但用户是否真的有意愿使用功能那就不得而知了（问题3）。\n那么如何做到这些呢？\n从OAuth2 授权码模式中可以总结出了这样的答案：\n 服务使用方在服务提供方注册自己的身份信息用于验证是否可信（client_id、client_sercet等） 通过重定向页面让用户确认授权信息（用户信息通过用户登录或者已登录的会话获得，从而关联用户信息和服务使用方）  前面说到直接与多个外部系统共享用户帐号密码的方式将面临的问题，正好可以基于以上两点来解决：\n 用户更改密码，并不影响第三方系统（被授权方）在服务提供方已注册的身份信息，两者是独立的 各第三方系统（被授权方）在服务提供方注册的信息也是相互独立的，限制其中一个并不影响其他第三方系统 不止第三方系统，用户也参与了授权（重定向页面验证用户身份） 用户可以根据自己的意愿来确认是否授权（比如授予修改密码的权限）  当然不能避免的是引入需要考虑的新问题：\n 如何避免第三方系统身份信息的泄露、被盗用的情况（类似用户帐号密码泄露的情况） 用户直接参与授权验证，交互会更加复杂，给外部的可乘之机就越多 用户的每次授权的时效性（只有一段时间内可用，避免一次授权一直使用，当然也存在特殊场景） 如何避免用户被钓鱼授权（用户在本系统已登录认证过，然后在互联网点击攻击者放置的钓鱼链接以获取其他正规网站的授权）  等等一系列问题，不过现在不需太过深入在意。\n以上是个人学习OAuth2.0授权码模式同时思考的总结，总而言之授权过程的需要考虑：\n 服务使用方是否是可信的 用户信息是否真实 用户是否有意愿来完成授权 互联网的一些安全问题  注：如果已经了解过OAuth2.0的密码模式，或许会注意到该模式并没有验证服务使用方的信息（client_id、client_sercet等），可以说是从传统的用户帐号密码验证演变来的，能提供帐号密码既是可信的（被盗和泄露另说），官方文档上说明(需保密就用授权码模式)：\n If the client type is confidential or the client was issued client\ncredentials (or assigned other authentication requirements), the\nclient MUST authenticate with the authorization server as described\nin Section 3.2.1.\n OAuth2.0授权 首先，和上面思考怎么授权之前一样，OAuth2.0对涉及的角色给出了相关定义。\n resource owner: 资源拥有者，可以理解成常见的用户。\nclient：客户端，请求被授权的应用。可以理解授权服务的使用方。\nresource server：实际提供资源数据的服务器\nauthorization server: 授权服务器\n 在我的理解中，resource server+authorization server可以合称为服务提供方，因为这两者都是由其提供的。只是这里的定义更加详细具体。\n再看OAuth 2.0的抽象运行流程如下图，摘自RFC 6749。\n\n这个图我在我学习OAuth2.0的整个过程中至少看到过五次，然而就算一遍又一遍其中的每一步的意义，始终感觉自己哪里不明白（不知道有人跟我一样不）\n起初我有些困惑这个图为啥和自己印象中的OAuth2.0授权流程不一样，几经思考还是暂时放在一边\n后来才逐渐反应过来这不过是抽象的授权协议流程（印象中的是几个模式具体的流程）\n但紧接着我又疑惑了：为什么抽象的授权协议流程是这样的？与几个模式具体的流程差异这么大？这样的流程有什么好处？\n抽象的授权流程换言之意味着最符合理想效果的流程，所以我反过来思考什么是理想的授权效果？通常的授权方式又有哪里不尽人意？该怎样授权？\n我不想一来就解释（或者说翻译）图中每一步的意义，将自己代入体验生活中的“授权”后再类比图例，更令自己体会深刻（俗称举个栗子）。\n设想一个情景：找人装修 角色： 1. 我们：高大上小区的物业和门卫 2. 张三：他在我们小区刚买了套新房，平时996 3. 李四：老实巴交专门接私活干的装修工 事件：张三请李四帮他装修房子 星期一早上10点，李四拎着他的麻袋来给张三干活。 我一瞧，这么大一个麻袋干嘛的，难不成是人口贩子？不行，得好好盘问盘问：“你谁？来这干嘛得？”。 李四憨厚一笑道：“我是来装修得，张三请我来的，就是1栋2单元3楼4户的业主”。 1234号业主不刚好是物业上面那户程序猿吗，确实是刚买房子还没装，最近常来物业转悠还算挺熟的，我一皱眉，刚想开口再问时，就见他放下麻袋，抽裤兜里掏出一张对半折的整整齐齐的纸条递给我。 “这是张三他给我的委托书，你给看看呢。”他憨笑着摸了摸后脑勺说到。 我接过纸条展开一看眉头一展，这歪七拐八的字确实是那苦逼程序猿张三的真迹，而且这人老实巴交的看也不像假话。“行吧，这委托书我就收下了，你跟我去物业来办个临时工作证，后面就用它进出吧。” 于是李四老老实实跟着我办了证，天天拿着他的临时出入证勤勤恳恳去帮张三装房子去了。 可以代入不同角色去思考，这里从物业门卫的角度考虑，是为了确保小区内的所有居民的安全，不只是特例张三。\n整理下几者之间是如何交互的：\n 张三、李四早就知道李四是没法直接进小区的，所以张三事先给李四整了一张能证实张三身份并说明李四事由的委托书。 李四将委托书交由交由门卫进行验证真实性，并为其办理临时出入证。 李四使用临时身份证开始自己的工作  再看OAuth2.0抽线流程图：\nA：Client找Resource Owner要一个证明，为了完成他委托自己办的事 B：Resource Owner给Client一个证明，这个证明同时记录了委托人、被委托人、委托事项等 C：Client将证明给Authorization server进行验证（这里只是抽象流程，验证真实性的方式不需太过深入） D：Authorization server觉得证明没啥问题，再给了Client整个临时访问的令牌用 E：Client拿着令牌到Resource server确认，并告知他想干嘛 F：Resource server将Client想要的结果数据 这不就像：\n 张三是Resource Owner 李四是Client 物业门卫是Authorization server  或许你会在意Resource server体现在哪，是门卫？房子？E、F步骤怎么体现？\n试想张三老婆天天在家，她知道张三请了装修工，但到底是谁又不清楚，所以李四来的时候还是需要把工作证明给她看看才能进屋（她很信任门卫，毕竟都很有责任心）。\n这样的授权流程很符合理想的效果，但是还需要考虑更加具体现实的问题\nB步骤中Client的证明，是不是他伪造的，就好比看似人畜无害的李四实际是一个诈骗老手，擅长模仿各种字迹呢？或者偷的别人冒名顶替的呢？\n所以这个抽象的授权流程难点无疑在于如何保证B步骤中的\nOAuth 2.0 Endpoints\n解惑   Q:为什么要分授权服务中心和资源服务器？\n  Q:为什么需要有一步Authorization Grant，再换取Access token\n首先，肯定是为了安全！\n授权认证需要client_id、client_sercet，而获取Authorization Grant通常是通过浏览器，直接传输client_sercet是不安全的，所以在此阶段是没有参与认证校验，在应用服务器上还需要用client_sercet、Authorization Grant等信息再一步获取Access token，这是为了保证client_sercet不被泄露！同时也验证了应用程序服务器真实性。\n  Q:为什么简化模式不校验client_sercet直接获取到Access token?\n  stackoverflow\n  Q:简化模式的token获取脚本指的是从授权服务器还是资源服务器?\n  Q:资源服务器如何确认令牌是否真实有效？\n  Q:关于参数state有什么意义\n保持请求设备一致性\n也就是防止CSRF攻击，简单的说就是攻击者用他已有的帐号和他的state向授权服务器申请Authorization Grant后，用其伪造一个链接让用户点击，这样用户以为他授权的是自己帐号，但实际是攻击者专门的帐号，之后用户的所有操作都可被攻击者看见，如果向该帐号推送数据（比如保存文件，密码，转账等等），那就完蛋了！所以说对state进行校验是有必要的，要是传出的和传入的state不等，那直接拒绝就完事了!\n个人觉得 state 如果为固定值的话意义不大，攻击者知道了就形同摆设，最好是动态的！\n可以从以下文章中了解更多\n 关于 OAuth2.0 安全性你应该要知道的一些事 移花接木：针对OAuth2的CSRF攻击 技术干货 | OAuth2.0的安全解析    Q:资源服务器在接受每个请求时，是怎么判断令牌的真实有效性的？\n  参考  OAuth 2.0 的一个简单解释 - 阮一峰 理解OAuth2.0 - 阮一峰 OAuth 2.0 的四种方式 - 阮一峰 OAuth2.0 详解 - 知乎 The OAuth 2.0 Authorization Framework - rfc6749 从“黑掉Github”学Web安全开发 OAuth 2.0 Tutorial 关于 OAuth2.0 安全性你应该要知道的一些事 - chrisyue 移花接木：针对OAuth2的CSRF攻击 技术干货 | OAuth2.0的安全解析  ","permalink":"https://zone.dnfn.tech/2021/07/202107171742448/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e记录下授权\u003ccode\u003eoauth2\u003c/code\u003e的理解，还有自己的疑问等等。\u003c/p\u003e","title":"OAuth2"},{"content":"简介 本文记录了ThreadGroup的作用和特性，它和线程池的区别。\n前言 同事突然问我线程组ThreadGroup与线程池ThreadPool有什么区别？又有啥作用？\n说实话，确实自己理解的不够清晰，讨论过后整理记录下自己的理解\n各自的意义 字面意义：\n 线程池：空闲的线程放在一起管理 线程组：对线程进行分组管理  从定义上看：\n 线程池是一种池化实现，为了重复利用空闲的线程资源，避免系统频繁创建线程造成的大量资源消耗。 线程组是一个抽象集合，为了统一方便管理多个线程。  当然线程池也可以理解为一类线程的集合，不过这类集合与线程组同样是有区别的：\n 线程池是空闲的线程的集合 线程组是所有活动中的线程和线程组的集合  为什么是所有？\nJVM启动时会创建一个名为system的线程组，它并没有parent对象。\n/** * Creates an empty Thread group that is not in any Thread group. * This method is used to create the system Thread group. */ private ThreadGroup() { // called from C code  this.name = \u0026#34;system\u0026#34;;  this.maxPriority = Thread.MAX_PRIORITY; this.parent = null; } 而在JVM启动完成后，程序运行时创建的ThreadGroup会放入当前线程所在的线程组，这意味着之后的线程都有一个parent对象。\npublic ThreadGroup(String name) { this(Thread.currentThread().getThreadGroup(), name); } public ThreadGroup(ThreadGroup parent, String name) { this(checkParentAccess(parent), parent, name); } private ThreadGroup(Void unused, ThreadGroup parent, String name) { this.name = name; this.maxPriority = parent.maxPriority; this.daemon = parent.daemon; this.parent = parent; parent.add(this); } 而创建Thread时，默认会加入当前线程所在的线程组。\nprivate Thread(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) { // ...  if (g == null) { if (security != null) { /* security.getThreadGroup()方法用于在被调用期间返回要在其中创建任何新线程的线程组，否则，当在调用期间没有与其相关的新创建线程时，它将返回当前线程的线程组 */ g = security.getThreadGroup(); } /* 默认加入父线程所在的线程组 */ if (g == null) { g = parent.getThreadGroup(); } } /* checkAccess regardless of whether or not threadgroup is explicitly passed in. */ g.checkAccess(); // ...  g.addUnstarted(); this.group = g; // ... } 由此可见JVM启动时会创建一个默认名为system的线程组，由这个线程组一直往下创建Thread和ThreadGroup，能够想象这形成的是一个树结构，根节点便是这个system的线程组。\n\n为什么时活动中?\n线程只有执行start时才会加入ThreadGroup，而当其退出则会被移出。\n// Thread.class public synchronized void start() { /** * This method is not invoked for the main method thread or \u0026#34;system\u0026#34; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \u0026#34;NEW\u0026#34;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group\u0026#39;s list of threads * and the group\u0026#39;s unstarted count can be decremented. */ group.add(this);  boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this);  } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } // Thread.class private void exit() { if (threadLocals != null \u0026amp;\u0026amp; TerminatingThreadLocal.REGISTRY.isPresent()) { TerminatingThreadLocal.threadTerminated(); } if (group != null) { group.threadTerminated(this);  group = null; } /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; } // ThreadGroup.class void threadStartFailed(Thread t) { synchronized(this) { remove(t);  nUnstartedThreads++; } } void threadTerminated(Thread t) { synchronized (this) { remove(t);  if (nthreads == 0) { notifyAll(); } if (daemon \u0026amp;\u0026amp; (nthreads == 0) \u0026amp;\u0026amp; (nUnstartedThreads == 0) \u0026amp;\u0026amp; (ngroups == 0)) { destroy(); } } } 各自的作用 线程池的作用上面已经说过了，是为了减小系统频繁创建线程带来的资源消耗，而线程组为了统一方便的管理组内多个线程提供很多方法：\n   返回类型 方法 描述     void suspend() 暂停所有线程   void resume() 恢复所有线程   void stop() 停止所有线程   void interrupt() 中断所有线程   void setMaxPriority(int pri) 设置最大优先级     注： 由于线程安全问题，suspend()、resume() 和 stop() 都已经被标记过时了。\n Thread.stop可能导致数据不一致问题被弃用\nThread.suspend和Thread.resume也容易导致死锁\n上面的方法都是批量修改管理线程的，ThreadGroup还提供了许多查看状态的方法\nint activeCount() // 返回此线程组及其子组中活动线程数的估计值 int activeGroupCount() //返回此线程组及其子组中活动线程组数的估计值 int enumerate(Thread[] list) // 将此线程组及其子组中的每个活动线程复制到指定的数组中 int enumerate(Thread[] list, boolean recurse) // 将此线程组及其子组中的每个活动线程复制到指定的数组中 int enumerate(ThreadGroup[] list) // 将此线程组及其子组中的每个活动线程组复制到指定的数组中 int enumerate(ThreadGroup[] list, boolean recurse) // 将此线程组及其子组中的每个活动线程组复制到指定的数组中 void list() // 将有关此线程组的信息打印到标准输出。 字段属性 public class ThreadGroup implements UncaughtExceptionHandler { // 父线程组对象  private final ThreadGroup parent; // 线程组名  String name; // 最高优先级  int maxPriority; // 是否已销毁  boolean destroyed; // 是否守护线程组  boolean daemon; // 虚拟机自动挂起  boolean vmAllowSuspension; // 未启动的线程数量  int nUnstartedThreads; // 已启动的线程总数  int nthreads; // 已启动的线程数组  Thread[] threads; // 线程组总数  int ngroups; // 线程组数组  ThreadGroup[] groups; // ... methods } 其中：\n maxPriority不能大于parent.maxPriority，根线程组的maxPriority为 10 还存在运行中的线程时无法调用destroy，无法销毁，销毁是递归的 daemon表示为守护线程组，与线程的daemon无关，详见 守护线程组 new Thread(...)就会使nUnstartedThreads++ nthreads是threads的最后一个元素的下标，当Thread.start()时加一，并可触发扩容 threads和groups初始容量为4，2倍数扩大  守护线程组 ThreadGroup和Thread都有daemon属性，ThreadGroup又可以统一管理Thread，很容易让人认为ThreadGroup.setDaemon(boolean)也是循环遍历设置Thread.daemon，然而并不是这样（之前理解错了 😂）。\n在ThreadGroup.setDaemon(boolean)源码上有一段说明：\n/** * Changes the daemon status of this thread group. * \u0026lt;p\u0026gt; * First, the {@code checkAccess} method of this thread group is * called with no arguments; this may result in a security exception. * \u0026lt;p\u0026gt; * A daemon thread group is automatically destroyed when its last * thread is stopped or its last thread group is destroyed. * * @param daemon if {@code true}, marks this thread group as * a daemon thread group; otherwise, marks this * thread group as normal. * @throws SecurityException if the current thread cannot modify * this thread group. * @see java.lang.SecurityException * @see java.lang.ThreadGroup#checkAccess() * @since 1.0 */ public final void setDaemon(boolean daemon) { checkAccess(); this.daemon = daemon; } 大致意义就是线程组的daemon属性表示当它内部没有active的线程时，它会自动销毁。\n当一个守护线程组ThreadGroup不存在活动中的线程或者子线程组时，它会执行销毁方法destroy:\nprivate void remove(ThreadGroup var1) { synchronized(this) { if (!this.destroyed) { for(int var3 = 0; var3 \u0026lt; this.ngroups; ++var3) { if (this.groups[var3] == var1) { --this.ngroups; System.arraycopy(this.groups, var3 + 1, this.groups, var3, this.ngroups - var3); this.groups[this.ngroups] = null; break; } } if (this.nthreads == 0) { this.notifyAll(); } if (this.daemon \u0026amp;\u0026amp; this.nthreads == 0 \u0026amp;\u0026amp; this.nUnstartedThreads == 0 \u0026amp;\u0026amp; this.ngroups == 0) { this.destroy();  } } } } void threadTerminated(Thread t) { synchronized (this) { remove(t); if (nthreads == 0) { notifyAll(); } if (daemon \u0026amp;\u0026amp; (nthreads == 0) \u0026amp;\u0026amp; (nUnstartedThreads == 0) \u0026amp;\u0026amp; (ngroups == 0)) { destroy();  } } } 相关 ThreadGroup in Java\nJava 并发 之 线程组 ThreadGroup 介绍\nJava多线程系列——过期的suspend()挂起、resume()继续执行线程\nThreadGroup\n","permalink":"https://zone.dnfn.tech/2021/06/2021062424104134/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e本文记录了\u003ccode\u003eThreadGroup\u003c/code\u003e的作用和特性，它和线程池的区别。\u003c/p\u003e","title":"ThreadGroup 线程池"},{"content":"简介 主要记录了使用 spring 重定向时遇到的问题，以及重新熟悉 HTTP 3xx 中重定向状态码的意义。\n前言 最近接手的一个项目需要在 POST 接口中处理逻辑，完成后让浏览器重定向到首页，请求方式需要变成 GET 。\n结果一直提示 405 方法不支持。折腾了个把都没找到问题原因，没想到是重定向的状态码有问题。\n问题 一般情况下，在 Spring下重定向到页面时会使用 ModelAndView，也就是这样：\n@PostMapping(\u0026#34;handle\u0026#34;) public String handle(){ // do something ...  return \u0026#34;redirect:/\u0026#34;; } 这种类似的情况下返回的是：\nPOST http://localhost:8080/tdh-portal/cas HTTP/1.1 302 Found Content-Language: zh-CN Location: http://localhost:8080/ Content-Length: 0 Server: Jetty(9.4.z-SNAPSHOT) \u0026lt;Response body is empty\u0026gt; Response code: 302 (Found); Time: 119ms; Content length: 0 bytes 也不知道从哪里复制了一段代码 😂 ，主要部分如下：\n@PostMapping(\u0026#34;handle\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handle(){ // do something ...  return ResponseEntity .status(HttpStatus.TEMPORARY_REDIRECT) .header(HttpHeaders.LOCATION, \u0026#34;/\u0026#34;) .build(); } 响应信息则是这样\nPOST http://localhost:8080/handle HTTP/1.1 307 Temporary Redirect Set-Cookie: JSESSIONID=node0123krmz4upibb18jz7ov4us1pw1.node0;Path=/ Expires: Thu, 01 Jan 1970 00:00:00 GMT Location: / Content-Length: 0 Server: Jetty(9.4.z-SNAPSHOT) \u0026lt;Response body is empty\u0026gt; Response code: 307 (Temporary Redirect); Time: 4916ms; Content length: 0 bytes 可以看到两种方式主要响应码不同 302 与 307。经过查阅相关文档发现意义大不相同：\n   编码 含义 处理方法     302 Found GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。1   307 Temporary Redirect 方法和消息主体都不发生变化。    典型应用场景：\n302：由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。\n307：由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。\n302 与 307 最主要的不同点在于方法和消息体是否发生变化。所以导致用POST方法请求接口时无法重定向到使用GET方法的页面。\n经过查看重定向相关的响应码规范，修改代码：\n@PostMapping(\u0026#34;handle\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handle(){ // do something ...  return ResponseEntity .status(HttpStatus.SEE_OTHER) .header(HttpHeaders.LOCATION, \u0026#34;/\u0026#34;) .build(); } 这里使用 303 主要是为了验证成功跳转防止重复触发。\nHTTP 的重定向  不同类型的重定向映射可以划分为三个类别：\n 永久重定向 临时重定向 特殊重定向   永久重定向意味着原来的URL不应再被使用，而应优选用新的URL，这种关系是永久性的，通常应用于网站重构,301,308。\n临时重定向顾名思义这种关系是临时性的，有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问,302,303,307。\n特殊重定向是指 300 和 304，不同于其他方式直接给定url跳转重定向，没有特定的处理方式，也可能返回多个能重定向的url供手动选择。\n常见重定向响应码：\n   编码 含义 说明     300 Multiple Choice 不常用：所有的选项在消息主体的 HTML 页面中列出。   301 Moved Permanently GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。2   302 Found GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。3   303 See Other GET 方法不会发生变更，其他方法会变更为 GET 方法（消息主体会丢失）。   304 Not Modified 发送用于重新验证的条件请求。表示缓存的响应仍然是新鲜的并且可以使用。   307 Temporary Redirect 方法和消息主体都不发生变化。   308 Permanent Redirect 方法和消息主体都不发生变化。    延伸  HTTP 的重定向    该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 308 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://zone.dnfn.tech/2021/06/202106161641333/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e主要记录了使用 \u003ccode\u003espring\u003c/code\u003e 重定向时遇到的问题，以及重新熟悉 \u003ccode\u003eHTTP\u003c/code\u003e \u003ccode\u003e3xx\u003c/code\u003e 中重定向状态码的意义。\u003c/p\u003e","title":"Spring POST重定向到GET"},{"content":"简介  .java 文件编译后的 .class 文件内容究竟是怎样的？JVM 又是如果识别并加载 .class 文件的\n环境 Win10、Nixos\nJDK1.8\nClass文件内容 windows 下用 Powershell 查看字节码内容(十六进制)\nPS\u0026gt; cat Demo.java; public class Demo{} PS\u0026gt; javac.exe Demo.java; Format-Hex Demo.class Path: D:\\tmp\\java\\Demo.class 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000 CA FE BA BE 00 00 00 34 00 0D 0A 00 03 00 0A 07 Êþº¾...4........ 00000010 00 0B 07 00 0C 01 00 06 3C 69 6E 69 74 3E 01 00 ........\u0026lt;init\u0026gt;.. 00000020 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 .()V...Code...Li 00000030 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 0A neNumberTable... 00000040 53 6F 75 72 63 65 46 69 6C 65 01 00 09 44 65 6D SourceFile...Dem 00000050 6F 2E 6A 61 76 61 0C 00 04 00 05 01 00 04 44 65 o.java........De 00000060 6D 6F 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F mo...java/lang/O 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 00000080 01 00 01 00 04 00 05 00 01 00 06 00 00 00 1D 00 ................ 00000090 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 .......*·..±.... 000000A0 00 07 00 00 00 06 00 01 00 00 00 01 00 01 00 08 ................ 000000B0 00 00 00 02 00 09 ...... Linux 下命令行查看\n$ cat IDemo.java public interface IDemo{} $ javac IDemo.java ; hexdump IDemo.class 0000000 feca beba 0000 3400 0700 0007 0705 0600 0000010 0001 530a 756f 6372 4665 6c69 0165 0a00 0000020 4449 6d65 2e6f 616a 6176 0001 4905 6544 0000030 6f6d 0001 6a10 7661 2f61 616c 676e 4f2f 0000040 6a62 6365 0674 0001 0001 0002 0000 0000 0000050 0000 0001 0003 0000 0002 0004 000005b Class文件结构 一个完整的 class 文件大致可分为10个部分\n 魔数 版本号 常量池\n3.1 常量池计数器\n3.2 常量池数据区 访问标志 类索引 父类索引 接口\n7.1 接口计数器\n7.2 接口信息区 字段\n8.1 字段计数器\n8.2 字段信息区 方法\n9.1 方法计数器\n9.2 方法信息区 属性\n10.1 属性计数器\n10.2 属性信息区  关于class 文件的基本数据结构在 The Java Virtual Machine Specification (Second ed.)文档有详细的说明，如下:\nstruct Class_File_Format { u4 magic_number; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count - 1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } u4: 指4个字节的无符号整型\nu2: 指2个字节的无符号整型\n而cp_info、field_info、method_info、attribute_info 表示相关数据结构，长度均不定可变\nmagic_number 魔数(magic_number)是指某一文件格式下前几个固定字节值，一般用于识别文件格式，class文件的魔数固定为前4个字节，即：CA FE BA BE。\n至于它的来源和背后的故事可以看看 Wiki - Java class file 下的 Magic Number\nminor_version,major_version minor_version,major_version统称版本号，共占用4个字节，各分为2个字节的次版本号(minor_version)占第5、6字节位以及占第7、8字节位的主版本号(major_version)。版本号的作用为标识 class 文件是在具体哪个版本的 JVM 下生成的，让运行时环境的JVM确认是否可以加载此版本的class文件。\n以下常见主版本号(major_version)\n Java SE 17 = 61 (0x3D hex),\nJava SE 16 = 60 (0x3C hex),\nJava SE 15 = 59 (0x3B hex),\nJava SE 14 = 58 (0x3A hex),\nJava SE 13 = 57 (0x39 hex),\nJava SE 12 = 56 (0x38 hex),\nJava SE 11 = 55 (0x37 hex),\nJava SE 10 = 54 (0x36 hex),\nJava SE 9 = 53 (0x35 hex),\nJava SE 8 = 52 (0x34 hex),\nJava SE 7 = 51 (0x33 hex),\nJava SE 6.0 = 50 (0x32 hex),\nJava SE 5.0 = 49 (0x31 hex),\nJDK 1.4 = 48 (0x30 hex),\nJDK 1.3 = 47 (0x2F hex),\nJDK 1.2 = 46 (0x2E hex),\nJDK 1.1 = 45 (0x2D hex).\n constant_pool 常量池(constant_pool)存储了整个class文件下的字面量信息1\n常量池索引 常量池数据 延伸  Class 文件基本组织结构 Java class file - Wiki The class File Format    一般描述为固定不变的值，与\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://zone.dnfn.tech/2021/06/20210608875210/","summary":"\u003c!-- TOC off --\u003e\n\u003ch2 id=\"简介----omit-in-toc---\"\u003e简介 \u003c!-- omit in toc --\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.java\u003c/code\u003e 文件编译后的 \u003ccode\u003e.class\u003c/code\u003e 文件内容究竟是怎样的？\u003ccode\u003eJVM\u003c/code\u003e 又是如果识别并加载 \u003ccode\u003e.class\u003c/code\u003e 文件的\u003c/p\u003e","title":"Java Class 文件解析"},{"content":"","permalink":"https://zone.dnfn.tech/photo/","summary":"","title":"相册"},{"content":"","permalink":"https://zone.dnfn.tech/about/","summary":"","title":"关于我"},{"content":"简介 这是我的第一篇博客，这篇文章主要讲述了我搭建个人网站，以及如何自动构建发布静态页面的过程。\n前言 最近正好整理记录的笔记，之前写的比较随意，不太好整理，而且之前早就想搭建自己的个人博客网站，正好这次刚好又时间折腾折腾。\n搭建静态网站的框架网上比较多，文档和教程大部分也比较全，这次就直接选择口碑比较好也容易的 Hugo 在 Github 下搭建一个。\n安装 Hugo 在 Win10 下使用命令安装：\nscoop install hugo 验证安装:\nhugo version 这里的Scoop是 Win10 平台下的软件包管理工具之一，非常方便，感兴趣可在 GitHub或CodeChina 上查看。\n更多的安装方式和文档可以参看Hugo 官方安装教程.\n新建站点 新建站点项目\nhugo new site tech-blog Congratulations! Your new Hugo site is created in D:\\tech-blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 配置一款主题\nHugo主题提供了大量模板，这里用的主题是 PaperMod，详细文档(安装、配置)可以在Github上查看。\n更多的主题可以在 Hugo 主题 上查看\ncd tech-blog git init git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive 修改配置文件 config.toml 或者 config.yaml，.toml格式配置可参考官方文档，.\\config.yaml基本内容如下\nbaseurl:\u0026#34;http://zone.desiyonan.tech\u0026#34;title:\u0026#34;DnF\u0026#39;s Zone\u0026#34;defaultContentLanguage:zhhasCJKLanguage:truetheme:PaperMod# 主题params:AuthorName:\u0026#34;DnF\u0026#34;GitHubUser:\u0026#34;desiyonan\u0026#34;启动本地服务器\nhugo server -D Start building sites … | EN -------------------+----- Pages | 12 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 2 Sitemaps | 1 Cleaned | 0 Built in 35 ms Watching for changes in D:\\tech-blog\\{archetypes，content，data，layouts，static，themes} Watching for config changes in D:\\tech-blog\\config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 现在可以直接访问 http://localhost:1313/ 查看站点，不过要看文章具体效果可以先新建测试文章\nhugo new post/test.md \u0026#39;## Test\u0026#39; | out-file -a -e utf8 .\\content\\post\\test.md 访问 http://localhost:1313/post/test 就可以看到测试效果\n最后基本仓库的初始化\ngit commit -am \u0026#34;init\u0026#34; git push -u origin master 配置 Github Pages 基本框架已经搭建完成，需要能够在公网直接访问网页还需要配置 Github Pages。\n看了网上不少的博客，大部分都是在本地编辑 .md 文档，完成后通过 hugo 命令构建输出，最后再把输出的 public 目录推送到 Github 上。\n再尝试了一两次后太繁琐了，而且也不是我想要的效果，最后在知乎上看到最理想的效果：在本地编辑 .md 文档后推送到直接仓库后就可以通过公网看到效果。详细可以看知乎上的文章，说明的很清楚，重复的字也懒得码了，这里简单说明下大致流程和需要注意的地方。\n流程的大致原理:\n简单的说就是：\n 建两个仓库: 一个放文档源码，一个放构建后的页面代码 给源码仓库添加 Action，当推送 master 代码时自动构建页面，再推送到页面仓库  需要注意：\n 放构建后的静态页面的仓库需要配置 Github Pages 两个仓库需要一对 SSH 密钥，源码仓库配置私钥，页面仓库配置公钥 Github Action配置需要根据实际情况改动下  以下是我的改动后 Action 配置内容\nname:Deploy Hugo Site to Github Pages on Master Branchon:push:branches:- masterjobs:build-deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v1 # v2 does not have submodules option nowwith:submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.83.1\u0026#39;extended:true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}# 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名external_repository:desiyonan/zone# Pages 远程仓库publish_dir:\u0026#34;public\u0026#34;keep_files:false# remove existing filespublish_branch:master # deploying branchcommit_message:${{ github.event.head_commit.message }}不同的点：\nwith:submodules:true因为之前配置主题时是到了 git submodule，所以这里必要有，不然构建后没有主题。\n其次\nexternal_repository:desiyonan/zone# Pages 远程仓库publish_dir:\u0026#34;public\u0026#34;external_repository 是放页面仓库，publish_dir 是构建后需要推送的目录，hugo 默认的构建目录就是 public，具体配置看下 config.toml 或者 config.yaml 下有没有\npublishdir:xxxx不复杂，摸索个把小时就行了。两个仓库的关联配置到此位置，还需要最后一步配置页面仓库的Github Pages\n打开对应 Github 仓库页面，找到 Setting 页签，然后可以在侧边栏看到 Pages 设置\n需要配置的主要是 Source 选择分支和目录，自定义域名可以通过 Custom domain 配置，域名配置不是必须，如果配置了还需要新增 static/CNAME 文件，文件内容就是自定义的域名，中途改了几次域名就是没改文件导致访问不了网站。\nPS\u0026gt;cat static\\CNAME zone.desiyonan.tech 至此，耗时两天，一个完整的自动化部署个人博客终于搭建完了，网站的美化后面再一步步来。\n相关链接  Hugo homepage Hugo Install Hugo Docs Hugo Themes Theme PaperMod PaperMod - Github Hugo Config Scoop Github Scoop Codechina Hugo Gitee - Blog 使用Hugo搭建博客 - Blog Hugo Deploy Action  ","permalink":"https://zone.dnfn.tech/2021/05/8df2adb7809b41c597eb2efb10ed66db/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e这是我的第一篇博客，这篇文章主要讲述了我搭建个人网站，以及如何自动构建发布静态页面的过程。\u003c/p\u003e","title":"Hugo+Github 搭建个人网站"}]
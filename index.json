[{"content":"简介 本文了解 ThreadGroup 的作用和特性，而且为什么有且只有一个 system ThreadGroup。\n前言 今天同事突然问我线程组ThreadGroup 与线程池ThreadPool有什么区别？又有啥作用？\n说实话，确实自己理解的不够清晰，讨论过后整理记录下自己的理解\n各自的意义 字面意义：\n 线程池：(空闲的)线程放在一起管理 线程组：对线程进行分组管理  从定义上看：\n 线程池是一种池化实现，为了重复利用空闲的线程资源，避免系统频繁创建线程造成的大量资源消耗。 线程组是一个抽象集合，为了统一方便管理多个线程。  当然线程池也可以理解为一类线程的集合，不过这类集合与线程组同样是有区别的：\n 线程池是空闲的线程的集合 线程组是所有未结束的线程和未销毁的线程组的集合  各自的作用 线程池的作用上面已经说过了，是为了减小系统频繁创建线程带来的资源消耗，\n而线程组为了统一方便的管理组内多个线程提供很多方法：\n   返回类型 方法 描述     void suspend() 暂停所有线程   void resume() 恢复所有线程   void stop() 停止所有线程   void interrupt() 中断所有线程     注： 由于线程安全问题，suspend()、resume() 和 stop() 都已经被标记过时了。\n class ThreadGroup implements Thread.UncaughtExceptionHandler { private final ThreadGroup parent; // ...  Thread threads[]; // ...  ThreadGroup groups[]; // ... methods } 从以上属性中能看出这些特性:\n 线程组都有一个父组 一个线程组由多个线程和多个子组组成  它的相关构造函数\n/** * Creates an empty Thread group that is not in any Thread group. * This method is used to create the system Thread group. */ private ThreadGroup() { // called from C code  this.name = \u0026#34;system\u0026#34;; this.maxPriority = Thread.MAX_PRIORITY; this.parent = null; } 由此可见JVM启动时会创建一个默认名为 system 的线程组，由这个线程组一直往下创建Thread和ThreadGroup，\n能够想象这形成的是一个树结构，根节点便是这个system的线程组。\n守护线程组(Daemon) 线程组提供了多个方法管理线程，而且ThreadGroup 和 Thread 都有daemon属性，但是他们的意义是不一样的，\n也就是说ThreadGroup.setDaemon(boolean)并不能批量设置组能得线程为守护线程（之前理解错了 😂）。\n在源码上有一段说明：\n205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226  /** * Changes the daemon status of this thread group. * \u0026lt;p\u0026gt; * First, the {@code checkAccess} method of this thread group is * called with no arguments; this may result in a security exception. * \u0026lt;p\u0026gt; * A daemon thread group is automatically destroyed when its last * thread is stopped or its last thread group is destroyed. * * @param daemon if {@code true}, marks this thread group as * a daemon thread group; otherwise, marks this * thread group as normal. * @throws SecurityException if the current thread cannot modify * this thread group. * @see java.lang.SecurityException * @see java.lang.ThreadGroup#checkAccess() * @since 1.0 */ public final void setDaemon(boolean daemon) { checkAccess(); this.daemon = daemon; }   大致意义就是线程组的 daemon 属性表示当它内部没有 active 的线程时，它会自动销毁。\n当一个 Thread 结束时，他会从他所属的那个 ThreadGroup 中脱离:\n/** * Causes this thread to begin execution; the Java Virtual Machine * calls the {@code run} method of this thread. * \u0026lt;p\u0026gt; * The result is that two threads are running concurrently: the * current thread (which returns from the call to the * {@code start} method) and the other thread (which executes its * {@code run} method). * \u0026lt;p\u0026gt; * It is never legal to start a thread more than once. * In particular, a thread may not be restarted once it has completed * execution. * * @throws IllegalThreadStateException if the thread was already started. * @see #run() * @see #stop() */ public synchronized void start() { /** * This method is not invoked for the main method thread or \u0026#34;system\u0026#34; * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state \u0026#34;NEW\u0026#34;. */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group\u0026#39;s list of threads * and the group\u0026#39;s unstarted count can be decremented. */ group.add(this); boolean started = false; try { start0(); started = true; } finally { try { if (!started) { group.threadStartFailed(this); } } catch (Throwable ignore) { /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ } } } /** * This method is called by the system to give a Thread * a chance to clean up before it actually exits. */ private void exit() { if (threadLocals != null \u0026amp;\u0026amp; TerminatingThreadLocal.REGISTRY.isPresent()) { TerminatingThreadLocal.threadTerminated(); } if (group != null) { group.threadTerminated(this); group = null; } /* Aggressively null out all reference fields: see bug 4006245 */ target = null; /* Speed the release of some of these resources */ threadLocals = null; inheritableThreadLocals = null; inheritedAccessControlContext = null; blocker = null; uncaughtExceptionHandler = null; } 相关 ThreadGroup in Java\nJava 并发 之 线程组 ThreadGroup 介绍\nJava多线程系列——过期的suspend()挂起、resume()继续执行线程\n","permalink":"https://zone.desiyonan.tech/2021/06/2021062424104134/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e本文了解 \u003ccode\u003eThreadGroup\u003c/code\u003e 的作用和特性，而且为什么有且只有一个 \u003ccode\u003esystem ThreadGroup\u003c/code\u003e。\u003c/p\u003e","title":"ThreadGroup 线程池"},{"content":"简介 主要记录了使用 spring 重定向时遇到的问题，以及重新熟悉 HTTP 3xx 中重定向状态码的意义。\n前言 最近接手的一个项目需要在 POST 接口中处理逻辑，完成后让浏览器重定向到首页，请求方式需要变成 GET 。\n结果一直提示 405 方法不支持。折腾了个把都没找到问题原因，没想到是重定向的状态码有问题。\n问题 一般情况下，在 Spring下重定向到页面时会使用 ModelAndView，也就是这样：\n@PostMapping(\u0026#34;handle\u0026#34;) public String handle(){ // do something ...  return \u0026#34;redirect:/\u0026#34;; } 这种类似的情况下返回的是：\nPOST http://localhost:8080/tdh-portal/cas HTTP/1.1 302 Found Content-Language: zh-CN Location: http://localhost:8080/ Content-Length: 0 Server: Jetty(9.4.z-SNAPSHOT) \u0026lt;Response body is empty\u0026gt; Response code: 302 (Found); Time: 119ms; Content length: 0 bytes 也不知道从哪里复制了一段代码 😂 ，主要部分如下：\n@PostMapping(\u0026#34;handle\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handle(){ // do something ...  return ResponseEntity .status(HttpStatus.TEMPORARY_REDIRECT) .header(HttpHeaders.LOCATION, \u0026#34;/\u0026#34;) .build(); } 响应信息则是这样\nPOST http://localhost:8080/handle HTTP/1.1 307 Temporary Redirect Set-Cookie: JSESSIONID=node0123krmz4upibb18jz7ov4us1pw1.node0;Path=/ Expires: Thu, 01 Jan 1970 00:00:00 GMT Location: / Content-Length: 0 Server: Jetty(9.4.z-SNAPSHOT) \u0026lt;Response body is empty\u0026gt; Response code: 307 (Temporary Redirect); Time: 4916ms; Content length: 0 bytes 可以看到两种方式主要响应码不同 302 与 307。经过查阅相关文档发现意义大不相同：\n   编码 含义 处理方法     302 Found GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。1   307 Temporary Redirect 方法和消息主体都不发生变化。    典型应用场景：\n302：由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。\n307：由于不可预见的原因该页面暂不可用。在这种情况下，搜索引擎不会更新它们的链接。当站点支持非 GET 方法的链接或操作的时候，该状态码优于 302 状态码。\n302 与 307 最主要的不同点在于方法和消息体是否发生变化。所以导致用POST方法请求接口时无法重定向到使用GET方法的页面。\n经过查看重定向相关的响应码规范，修改代码：\n@PostMapping(\u0026#34;handle\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handle(){ // do something ...  return ResponseEntity .status(HttpStatus.SEE_OTHER) .header(HttpHeaders.LOCATION, \u0026#34;/\u0026#34;) .build(); } 这里使用 303 主要是为了验证成功跳转防止重复触发。\nHTTP 的重定向  不同类型的重定向映射可以划分为三个类别：\n 永久重定向 临时重定向 特殊重定向   永久重定向意味着原来的URL不应再被使用，而应优选用新的URL，这种关系是永久性的，通常应用于网站重构,301,308。\n临时重定向顾名思义这种关系是临时性的，有时候请求的资源无法从其标准地址访问，但是却可以从另外的地方访问,302,303,307。\n特殊重定向是指 300 和 304，不同于其他方式直接给定url跳转重定向，没有特定的处理方式，也可能返回多个能重定向的url供手动选择。\n常见重定向响应码：\n   编码 含义 说明     300 Multiple Choice 不常用：所有的选项在消息主体的 HTML 页面中列出。   301 Moved Permanently GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。2   302 Found GET 方法不会发生变更，其他方法有可能会变更为 GET 方法。3   303 See Other GET 方法不会发生变更，其他方法会变更为 GET 方法（消息主体会丢失）。   304 Not Modified 发送用于重新验证的条件请求。表示缓存的响应仍然是新鲜的并且可以使用。   307 Temporary Redirect 方法和消息主体都不发生变化。   308 Permanent Redirect 方法和消息主体都不发生变化。    延伸  HTTP 的重定向    该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 308 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 该规范无意使方法发生改变，但在实际应用中用户代理会这么做。 307 状态码被创建用来消除在使用非 GET 方法时的歧义行为。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://zone.desiyonan.tech/2021/06/202106161641333/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e主要记录了使用 \u003ccode\u003espring\u003c/code\u003e 重定向时遇到的问题，以及重新熟悉 \u003ccode\u003eHTTP\u003c/code\u003e \u003ccode\u003e3xx\u003c/code\u003e 中重定向状态码的意义。\u003c/p\u003e","title":"Spring POST重定向到GET"},{"content":"简介  .java 文件编译后的 .class 文件内容究竟是怎样的？JVM 又是如果识别并加载 .class 文件的\n环境 Win10、Nixos\nJDK1.8\nClass文件内容 windows 下用 Powershell 查看字节码内容(十六进制)\nPS\u0026gt; cat Demo.java; public class Demo{} PS\u0026gt; javac.exe Demo.java; Format-Hex Demo.class Path: D:\\tmp\\java\\Demo.class 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 00000000 CA FE BA BE 00 00 00 34 00 0D 0A 00 03 00 0A 07 Êþº¾...4........ 00000010 00 0B 07 00 0C 01 00 06 3C 69 6E 69 74 3E 01 00 ........\u0026lt;init\u0026gt;.. 00000020 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 .()V...Code...Li 00000030 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 0A neNumberTable... 00000040 53 6F 75 72 63 65 46 69 6C 65 01 00 09 44 65 6D SourceFile...Dem 00000050 6F 2E 6A 61 76 61 0C 00 04 00 05 01 00 04 44 65 o.java........De 00000060 6D 6F 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F mo...java/lang/O 00000070 62 6A 65 63 74 00 21 00 02 00 03 00 00 00 00 00 bject.!......... 00000080 01 00 01 00 04 00 05 00 01 00 06 00 00 00 1D 00 ................ 00000090 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 .......*·..±.... 000000A0 00 07 00 00 00 06 00 01 00 00 00 01 00 01 00 08 ................ 000000B0 00 00 00 02 00 09 ...... Linux 下命令行查看\n$ cat IDemo.java public interface IDemo{} $ javac IDemo.java ; hexdump IDemo.class 0000000 feca beba 0000 3400 0700 0007 0705 0600 0000010 0001 530a 756f 6372 4665 6c69 0165 0a00 0000020 4449 6d65 2e6f 616a 6176 0001 4905 6544 0000030 6f6d 0001 6a10 7661 2f61 616c 676e 4f2f 0000040 6a62 6365 0674 0001 0001 0002 0000 0000 0000050 0000 0001 0003 0000 0002 0004 000005b Class文件结构 一个完整的 class 文件大致可分为10个部分\n 魔数 版本号 常量池\n3.1 常量池计数器\n3.2 常量池数据区 访问标志 类索引 父类索引 接口\n7.1 接口计数器\n7.2 接口信息区 字段\n8.1 字段计数器\n8.2 字段信息区 方法\n9.1 方法计数器\n9.2 方法信息区 属性\n10.1 属性计数器\n10.2 属性信息区  关于class 文件的基本数据结构在 The Java Virtual Machine Specification (Second ed.)文档有详细的说明，如下:\nstruct Class_File_Format { u4 magic_number; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count - 1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count]; } u4: 指4个字节的无符号整型\nu2: 指2个字节的无符号整型\n而cp_info、field_info、method_info、attribute_info 表示相关数据结构，长度均不定可变\nmagic_number 魔数(magic_number)是指某一文件格式下前几个固定字节值，一般用于识别文件格式，class文件的魔数固定为前4个字节，即：CA FE BA BE。\n至于它的来源和背后的故事可以看看 Wiki - Java class file 下的 Magic Number\nminor_version,major_version minor_version,major_version统称版本号，共占用4个字节，各分为2个字节的次版本号(minor_version)占第5、6字节位以及占第7、8字节位的主版本号(major_version)。版本号的作用为标识 class 文件是在具体哪个版本的 JVM 下生成的，让运行时环境的JVM确认是否可以加载此版本的class文件。\n以下常见主版本号(major_version)\n Java SE 17 = 61 (0x3D hex),\nJava SE 16 = 60 (0x3C hex),\nJava SE 15 = 59 (0x3B hex),\nJava SE 14 = 58 (0x3A hex),\nJava SE 13 = 57 (0x39 hex),\nJava SE 12 = 56 (0x38 hex),\nJava SE 11 = 55 (0x37 hex),\nJava SE 10 = 54 (0x36 hex),\nJava SE 9 = 53 (0x35 hex),\nJava SE 8 = 52 (0x34 hex),\nJava SE 7 = 51 (0x33 hex),\nJava SE 6.0 = 50 (0x32 hex),\nJava SE 5.0 = 49 (0x31 hex),\nJDK 1.4 = 48 (0x30 hex),\nJDK 1.3 = 47 (0x2F hex),\nJDK 1.2 = 46 (0x2E hex),\nJDK 1.1 = 45 (0x2D hex).\n constant_pool 常量池(constant_pool)存储了整个class文件下的字面量信息1\n常量池索引 常量池数据 延伸  Class 文件基本组织结构 Java class file - Wiki The class File Format    一般描述为固定不变的值，与\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"https://zone.desiyonan.tech/2021/06/20210608875210/","summary":"\u003c!-- TOC off --\u003e\n\u003ch2 id=\"简介----omit-in-toc---\"\u003e简介 \u003c!-- omit in toc --\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003e.java\u003c/code\u003e 文件编译后的 \u003ccode\u003e.class\u003c/code\u003e 文件内容究竟是怎样的？\u003ccode\u003eJVM\u003c/code\u003e 又是如果识别并加载 \u003ccode\u003e.class\u003c/code\u003e 文件的\u003c/p\u003e","title":"Java Class 文件解析"},{"content":"","permalink":"https://zone.desiyonan.tech/photo/","summary":"","title":"相册"},{"content":"","permalink":"https://zone.desiyonan.tech/about/","summary":"","title":"关于我"},{"content":"简介 这是我的第一篇博客，这篇文章主要讲述了我搭建个人网站，以及如何自动构建发布静态页面的过程。\n前言 最近正好整理记录的笔记，之前写的比较随意，不太好整理，而且之前早就想搭建自己的个人博客网站，正好这次刚好又时间折腾折腾。\n搭建静态网站的框架网上比较多，文档和教程大部分也比较全，这次就直接选择口碑比较好也容易的 Hugo 在 Github 下搭建一个。\n安装 Hugo 在 Win10 下使用命令安装：\nscoop install hugo 验证安装:\nhugo version 这里的Scoop是 Win10 平台下的软件包管理工具之一，非常方便，感兴趣可在 GitHub或CodeChina 上查看。\n更多的安装方式和文档可以参看Hugo 官方安装教程.\n新建站点 新建站点项目\nhugo new site tech-blog Congratulations! Your new Hugo site is created in D:\\tech-blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. 配置一款主题\nHugo主题提供了大量模板，这里用的主题是 PaperMod，详细文档(安装、配置)可以在Github上查看。\n更多的主题可以在 Hugo 主题 上查看\ncd tech-blog git init git submodule add https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod --depth=1 git submodule update --init --recursive 修改配置文件 config.toml 或者 config.yaml，.toml格式配置可参考官方文档，.\\config.yaml基本内容如下\nbaseurl:\u0026#34;http://zone.desiyonan.tech\u0026#34;title:\u0026#34;DnF\u0026#39;s Zone\u0026#34;defaultContentLanguage:zhhasCJKLanguage:truetheme:PaperMod# 主题params:AuthorName:\u0026#34;DnF\u0026#34;GitHubUser:\u0026#34;desiyonan\u0026#34;启动本地服务器\nhugo server -D Start building sites … | EN -------------------+----- Pages | 12 Paginator pages | 0 Non-page files | 0 Static files | 1 Processed images | 0 Aliases | 2 Sitemaps | 1 Cleaned | 0 Built in 35 ms Watching for changes in D:\\tech-blog\\{archetypes，content，data，layouts，static，themes} Watching for config changes in D:\\tech-blog\\config.yaml Environment: \u0026#34;development\u0026#34; Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 现在可以直接访问 http://localhost:1313/ 查看站点，不过要看文章具体效果可以先新建测试文章\nhugo new post/test.md \u0026#39;## Test\u0026#39; | out-file -a -e utf8 .\\content\\post\\test.md 访问 http://localhost:1313/post/test 就可以看到测试效果\n最后基本仓库的初始化\ngit commit -am \u0026#34;init\u0026#34; git push -u origin master 配置 Github Pages 基本框架已经搭建完成，需要能够在公网直接访问网页还需要配置 Github Pages。\n看了网上不少的博客，大部分都是在本地编辑 .md 文档，完成后通过 hugo 命令构建输出，最后再把输出的 public 目录推送到 Github 上。\n再尝试了一两次后太繁琐了，而且也不是我想要的效果，最后在知乎上看到最理想的效果：在本地编辑 .md 文档后推送到直接仓库后就可以通过公网看到效果。详细可以看知乎上的文章，说明的很清楚，重复的字也懒得码了，这里简单说明下大致流程和需要注意的地方。\n流程的大致原理:\n简单的说就是：\n 建两个仓库: 一个放文档源码，一个放构建后的页面代码 给源码仓库添加 Action，当推送 master 代码时自动构建页面，再推送到页面仓库  需要注意：\n 放构建后的静态页面的仓库需要配置 Github Pages 两个仓库需要一对 SSH 密钥，源码仓库配置私钥，页面仓库配置公钥 Github Action配置需要根据实际情况改动下  以下是我的改动后 Action 配置内容\nname:Deploy Hugo Site to Github Pages on Master Branchon:push:branches:- masterjobs:build-deploy:runs-on:ubuntu-18.04steps:- uses:actions/checkout@v1 # v2 does not have submodules option nowwith:submodules:true- name:Setup Hugouses:peaceiris/actions-hugo@v2with:hugo-version:\u0026#39;0.83.1\u0026#39;extended:true- name:Buildrun:hugo --minify- name:Deployuses:peaceiris/actions-gh-pages@v3with:deploy_key:${{ secrets.ACTIONS_DEPLOY_KEY }}# 这里的 ACTIONS_DEPLOY_KEY 则是上面设置 Private Key的变量名external_repository:desiyonan/zone# Pages 远程仓库publish_dir:\u0026#34;public\u0026#34;keep_files:false# remove existing filespublish_branch:master # deploying branchcommit_message:${{ github.event.head_commit.message }}不同的点：\nwith:submodules:true因为之前配置主题时是到了 git submodule，所以这里必要有，不然构建后没有主题。\n其次\nexternal_repository:desiyonan/zone# Pages 远程仓库publish_dir:\u0026#34;public\u0026#34;external_repository 是放页面仓库，publish_dir 是构建后需要推送的目录，hugo 默认的构建目录就是 public，具体配置看下 config.toml 或者 config.yaml 下有没有\npublishdir:xxxx不复杂，摸索个把小时就行了。两个仓库的关联配置到此位置，还需要最后一步配置页面仓库的Github Pages\n打开对应 Github 仓库页面，找到 Setting 页签，然后可以在侧边栏看到 Pages 设置\n需要配置的主要是 Source 选择分支和目录，自定义域名可以通过 Custom domain 配置，域名配置不是必须，如果配置了还需要新增 static/CNAME 文件，文件内容就是自定义的域名，中途改了几次域名就是没改文件导致访问不了网站。\nPS\u0026gt;cat static\\CNAME zone.desiyonan.tech 至此，耗时两天，一个完整的自动化部署个人博客终于搭建完了，网站的美化后面再一步步来。\n相关链接  Hugo homepage Hugo Install Hugo Docs Hugo Themes Theme PaperMod PaperMod - Github Hugo Config Scoop Github Scoop Codechina Hugo Gitee - Blog 使用Hugo搭建博客 - Blog Hugo Deploy Action  ","permalink":"https://zone.desiyonan.tech/2021/05/8df2adb7809b41c597eb2efb10ed66db/","summary":"\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\n\u003cp\u003e这是我的第一篇博客，这篇文章主要讲述了我搭建个人网站，以及如何自动构建发布静态页面的过程。\u003c/p\u003e","title":"Hugo+Github 搭建个人网站"}]